# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-events` gem.
# Please instead update this file by running `bin/tapioca gem dry-events`.

# source://dry-events//lib/dry/events/constants.rb#5
module Dry
  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject.rb#61
    def AutoInject(container, options = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli.rb#221
    def CLI(registry_or_command = T.unsafe(nil), &block); end

    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.0.0/lib/dry/core.rb#41
    def Equalizer(*keys, **options); end
  end
end

# source://dry-events//lib/dry/events/constants.rb#6
module Dry::Events
  include ::Dry::Core::Constants
end

# Event bus
#
# An event bus stores listeners (callbacks) and events
#
# @api private
#
# source://dry-events//lib/dry/events/bus.rb#12
class Dry::Events::Bus
  # Initialize a new event bus
  #
  # @api private
  # @param events [Hash] A hash with events
  # @param listeners [Hash] A hash with listeners
  # @return [Bus] a new instance of Bus
  #
  # source://dry-events//lib/dry/events/bus.rb#27
  def initialize(events: T.unsafe(nil), listeners: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#51
  def attach(listener, filter); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-events//lib/dry/events/bus.rb#90
  def can_handle?(object_or_event_id); end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#62
  def detach(listener); end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#15
  def events; end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#19
  def listeners; end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#33
  def process(event_id, payload); end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#44
  def publish(event_id, payload); end

  # @api private
  #
  # source://dry-events//lib/dry/events/bus.rb#72
  def subscribe(event_id, filter, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-events//lib/dry/events/bus.rb#78
  def subscribed?(listener); end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Event object
#
# @api public
#
# source://dry-events//lib/dry/events/event.rb#10
class Dry::Events::Event
  include ::Dry::Core::Equalizer::Methods

  # Initialize a new event
  #
  # @api private
  # @param id [Symbol, String] The event identifier
  # @param payload [Hash]
  # @return [Event]
  #
  # source://dry-events//lib/dry/events/event.rb#42
  def initialize(id, payload); end

  # Get data from the payload
  #
  # @api public
  # @param name [String, Symbol]
  #
  # source://dry-events//lib/dry/events/event.rb#52
  def [](name); end

  # @api public
  #
  # source://dry-events//lib/dry/events/event.rb#25
  def id; end

  # @api private
  #
  # source://dry-events//lib/dry/events/event.rb#85
  def listener_method; end

  # Get or set a payload
  #
  # @api public
  # @overload
  # @overload payload
  #
  # source://dry-events//lib/dry/events/event.rb#76
  def payload(data = T.unsafe(nil)); end

  # Coerce an event to a hash
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-events//lib/dry/events/event.rb#61
  def to_h; end

  # Coerce an event to a hash
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-events//lib/dry/events/event.rb#61
  def to_hash; end

  class << self
    # @api private
    # @raise [InvalidEventNameError]
    #
    # source://dry-events//lib/dry/events/event.rb#28
    def new(id, payload = T.unsafe(nil)); end
  end
end

# @api public
#
# source://dry-events//lib/dry/events/event.rb#20
Dry::Events::Event::DOT = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-events//lib/dry/events/event.rb#13
class Dry::Events::Event::InvalidEventNameError < ::StandardError
  # source://dry-events//lib/dry/events/event.rb#15
  def initialize; end
end

# @api public
#
# source://dry-events//lib/dry/events/event.rb#21
Dry::Events::Event::UNDERSCORE = T.let(T.unsafe(nil), String)

# Event filter
#
# A filter cherry-picks probes payload of events.
# Events not matching the predicates don't fire callbacks.
#
# @api private
#
# source://dry-events//lib/dry/events/filter.rb#13
class Dry::Events::Filter
  # Create a new filter
  #
  # @api private
  # @param filter [Hash] Source filter
  # @return [Filter] a new instance of Filter
  #
  # source://dry-events//lib/dry/events/filter.rb#25
  def initialize(filter); end

  # Recursively build checks
  #
  # @api private
  #
  # source://dry-events//lib/dry/events/filter.rb#41
  def build_checks(filter, checks = T.unsafe(nil), keys = T.unsafe(nil)); end

  # Test event payload against the checks
  #
  # @api private
  # @param payload [Hash] Event payload
  #
  # source://dry-events//lib/dry/events/filter.rb#34
  def call(payload = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-events//lib/dry/events/filter.rb#18
  def checks; end

  # @api private
  #
  # source://dry-events//lib/dry/events/filter.rb#52
  def compare(path, predicate, payload); end

  # @api private
  #
  # source://dry-events//lib/dry/events/filter.rb#65
  def predicate(value); end
end

# @api private
#
# source://dry-events//lib/dry/events/filter.rb#14
Dry::Events::Filter::NO_MATCH = T.let(T.unsafe(nil), Object)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::IDENTITY = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://dry-events//lib/dry/events/publisher.rb#22
class Dry::Events::InvalidSubscriberError < ::StandardError
  # source://dry-events//lib/dry/events/publisher.rb#24
  def initialize(object_or_event_id); end
end

# source://dry-events//lib/dry/events/constants.rb#9
Dry::Events::LISTENERS_HASH = T.let(T.unsafe(nil), Concurrent::Map)

# Extension used for classes that can publish events
#
# @api public
# @example
#   class AppEvents
#   include Dry::Events::Publisher[:app]
#
#   register_event('users.created')
#   end
#
#   class CreateUser
#   attr_reader :events
#
#   def initialize(events)
#   @events = events
#   end
#
#   def call(user)
#   # do your thing
#   events.publish('users.created', user: user, time: Time.now)
#   end
#   end
#
#   app_events = AppEvents.new
#   create_user = CreateUser.new(app_events)
#
#   # this will publish "users.created" event with its payload
#   create_user.call(name: "Jane")
#
# source://dry-events//lib/dry/events/publisher.rb#77
class Dry::Events::Publisher < ::Module
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Publisher] a new instance of Publisher
  #
  # source://dry-events//lib/dry/events/publisher.rb#111
  def initialize(id); end

  # @api public
  #
  # source://dry-events//lib/dry/events/publisher.rb#93
  def id; end

  # Hook for inclusions/extensions
  #
  # It registers the publisher class under global registry using the id
  #
  # @api private
  #
  # source://dry-events//lib/dry/events/publisher.rb#121
  def included(klass); end

  class << self
    # Create a publisher extension with the provided identifier
    #
    # @api public
    # @param id [Symbol, String] The identifier
    # @raise PublisherAlreadyRegisteredError
    # @return [Publisher]
    #
    # source://dry-events//lib/dry/events/publisher.rb#104
    def [](id); end

    # Internal publisher registry, which is used to identify them globally
    #
    # This allows us to have listener classes that can subscribe to events
    # without having access to instances of publishers yet.
    #
    # @api private
    #
    # source://dry-events//lib/dry/events/publisher.rb#86
    def registry; end
  end
end

# Class interface for publisher classes
#
# @api public
#
# source://dry-events//lib/dry/events/publisher.rb#133
module Dry::Events::Publisher::ClassMethods
  # Global registry with events
  #
  # @api private
  #
  # source://dry-events//lib/dry/events/publisher.rb#170
  def events; end

  # Global registry with listeners
  #
  # @api private
  #
  # source://dry-events//lib/dry/events/publisher.rb#177
  def listeners; end

  # Sets up event bus for publisher instances
  #
  # @api private
  # @return [Bus]
  #
  # source://dry-events//lib/dry/events/publisher.rb#163
  def new_bus; end

  # Register an event
  #
  # @api public
  # @param event_id [String] The event identifier
  # @param payload [Hash] Optional default payload
  #
  # source://dry-events//lib/dry/events/publisher.rb#140
  def register_event(event_id, payload = T.unsafe(nil)); end

  # Subscribe to an event
  #
  # @api public
  # @param event_id [Symbol, String] The event identifier
  # @param filter_hash [Hash] An optional filter for conditional listeners
  # @return [Class] publisher class
  #
  # source://dry-events//lib/dry/events/publisher.rb#153
  def subscribe(event_id, filter_hash = T.unsafe(nil), &block); end
end

# Instance interface for publishers
#
# @api public
#
# source://dry-events//lib/dry/events/publisher.rb#185
module Dry::Events::Publisher::InstanceMethods
  # Internal event bus
  #
  # @api private
  # @return [Bus]
  #
  # source://dry-events//lib/dry/events/publisher.rb#277
  def __bus__; end

  # Utility method which yields event with each of its listeners
  #
  # Listeners are already filtered out when filter was provided during
  # subscription
  #
  # param [Hash] payload An optional payload
  #
  # @api public
  # @param event_id [Symbol, String] The event identifier
  #
  # source://dry-events//lib/dry/events/publisher.rb#268
  def process(event_id, payload = T.unsafe(nil), &block); end

  # Publish an event
  #
  # @api public
  # @param event_id [String] The event identifier
  # @param payload [Hash] An optional payload
  #
  # source://dry-events//lib/dry/events/publisher.rb#205
  def publish(event_id, payload = T.unsafe(nil)); end

  # Register a new event type at instance level
  #
  # @api public
  # @param event_id [Symbol, String] The event identifier
  # @param payload [Hash] Optional default payload
  # @return [self]
  #
  # source://dry-events//lib/dry/events/publisher.rb#194
  def register_event(event_id, payload = T.unsafe(nil)); end

  # Subscribe to events.
  #
  # If the filter parameter is provided, filters events by payload.
  #
  # @api public
  # @param object_or_event_id [Symbol, String, Object] The event identifier or a listener object
  # @param filter_hash [Hash] An optional event filter
  # @return [Object] self
  #
  # source://dry-events//lib/dry/events/publisher.rb#225
  def subscribe(object_or_event_id, filter_hash = T.unsafe(nil), &block); end

  # Return true if a given listener has been subscribed to any event
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-events//lib/dry/events/publisher.rb#255
  def subscribed?(listener); end

  # Publish an event
  #
  # @api public
  # @param event_id [String] The event identifier
  # @param payload [Hash] An optional payload
  #
  # source://dry-events//lib/dry/events/publisher.rb#205
  def trigger(event_id, payload = T.unsafe(nil)); end

  # Unsubscribe a listener
  #
  # @api public
  # @param listener [Object] The listener object
  # @return [self]
  #
  # source://dry-events//lib/dry/events/publisher.rb#248
  def unsubscribe(listener); end
end

# Exception raised when the same publisher is registered more than once
#
# @api public
#
# source://dry-events//lib/dry/events/publisher.rb#14
class Dry::Events::PublisherAlreadyRegisteredError < ::StandardError
  # source://dry-events//lib/dry/events/publisher.rb#16
  def initialize(id); end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Events::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-events//lib/dry/events/publisher.rb#37
class Dry::Events::UnregisteredEventError < ::StandardError
  # source://dry-events//lib/dry/events/publisher.rb#38
  def initialize(object_or_event_id); end
end
