# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `childprocess` gem.
# Please instead update this file by running `bin/tapioca gem childprocess`.

module ChildProcess
  class << self
    # source://childprocess//lib/childprocess.rb#131
    def arch; end

    # source://childprocess//lib/childprocess.rb#15
    def build(*args); end

    # By default, a child process will inherit open file descriptors from the
    # parent process. This helper provides a cross-platform way of making sure
    # that doesn't happen for the given file/io.
    #
    # source://childprocess//lib/childprocess.rb#158
    def close_on_exec(file); end

    # @return [Boolean]
    #
    # source://childprocess//lib/childprocess.rb#64
    def jruby?; end

    # @return [Boolean]
    #
    # source://childprocess//lib/childprocess.rb#60
    def linux?; end

    # source://childprocess//lib/childprocess.rb#33
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://childprocess//lib/childprocess.rb#13
    def logger=(_arg0); end

    # source://childprocess//lib/childprocess.rb#15
    def new(*args); end

    # source://childprocess//lib/childprocess.rb#105
    def os; end

    # source://childprocess//lib/childprocess.rb#42
    def platform; end

    # source://childprocess//lib/childprocess.rb#52
    def platform_name; end

    # Set this to true to enable experimental use of posix_spawn.
    #
    # source://childprocess//lib/childprocess.rb#101
    def posix_spawn=(bool); end

    # @return [Boolean]
    #
    # source://childprocess//lib/childprocess.rb#72
    def posix_spawn?; end

    # @return [Boolean]
    #
    # source://childprocess//lib/childprocess.rb#56
    def unix?; end

    # @return [Boolean]
    #
    # source://childprocess//lib/childprocess.rb#68
    def windows?; end

    private

    # @return [Boolean] `true` if this Ruby represents `1` in 64 bits (8 bytes).
    #
    # source://childprocess//lib/childprocess.rb#199
    def is_64_bit?; end

    # source://childprocess//lib/childprocess.rb#179
    def warn_once(msg); end

    # Workaround: detect the situation that an older Darwin Ruby is actually
    # 64-bit, but is misreporting cpu as i686, which would imply 32-bit.
    #
    # @return [Boolean] `true` if:
    #   (a) on Mac OS X
    #   (b) actually running in 64-bit mode
    #
    # source://childprocess//lib/childprocess.rb#194
    def workaround_older_macosx_misreported_cpu?; end
  end
end

class ChildProcess::AbstractIO
  # @api private
  #
  # source://childprocess//lib/childprocess/abstract_io.rb#24
  def _stdin=(io); end

  # source://childprocess//lib/childprocess/abstract_io.rb#5
  def inherit!; end

  # Returns the value of attribute stderr.
  #
  # source://childprocess//lib/childprocess/abstract_io.rb#3
  def stderr; end

  # source://childprocess//lib/childprocess/abstract_io.rb#10
  def stderr=(io); end

  # Returns the value of attribute stdin.
  #
  # source://childprocess//lib/childprocess/abstract_io.rb#3
  def stdin; end

  # Returns the value of attribute stdout.
  #
  # source://childprocess//lib/childprocess/abstract_io.rb#3
  def stdout; end

  # source://childprocess//lib/childprocess/abstract_io.rb#15
  def stdout=(io); end

  private

  # @raise [SubclassResponsibility]
  #
  # source://childprocess//lib/childprocess/abstract_io.rb#31
  def check_type(io); end
end

class ChildProcess::AbstractProcess
  # Create a new process with the given args.
  #
  # @api private
  # @return [AbstractProcess] a new instance of AbstractProcess
  # @see ChildProcess.build
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#42
  def initialize(args); end

  # Is this process running?
  #
  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#133
  def alive?; end

  # Returns true if the process has exited and the exit code was not 0.
  #
  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#143
  def crashed?; end

  # Set the child's current working directory.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#25
  def cwd; end

  # Set the child's current working directory.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#25
  def cwd=(_arg0); end

  # Set this to true if you do not care about when or if the process quits.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#10
  def detach; end

  # Set this to true if you do not care about when or if the process quits.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#10
  def detach=(_arg0); end

  # Set this to true if you want to write to the process' stdin (process.io.stdin)
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#15
  def duplex; end

  # Set this to true if you want to write to the process' stdin (process.io.stdin)
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#15
  def duplex=(_arg0); end

  # Modify the child's environment variables
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#20
  def environment; end

  # Returns the value of attribute exit_code.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#5
  def exit_code; end

  # Did the process exit?
  #
  # @raise [SubclassResponsibility]
  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#113
  def exited?; end

  # Returns a ChildProcess::AbstractIO subclass to configure the child's IO streams.
  #
  # @raise [SubclassResponsibility]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#62
  def io; end

  # Set this to true to make the child process the leader of a new process group
  #
  # This can be used to make sure that all grandchildren are killed
  # when the child process dies.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#33
  def leader; end

  # Set this to true to make the child process the leader of a new process group
  #
  # This can be used to make sure that all grandchildren are killed
  # when the child process dies.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#33
  def leader=(_arg0); end

  # @raise [SubclassResponsibility]
  # @return [Integer] the pid of the process after it has started
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#70
  def pid; end

  # Wait for the process to exit, raising a ChildProcess::TimeoutError if
  # the timeout expires.
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#152
  def poll_for_exit(timeout); end

  # Launch the child process
  #
  # @return [AbstractProcess] self
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#80
  def start; end

  # Has the process started?
  #
  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#123
  def started?; end

  # Forcibly terminate the process, using increasingly harsher methods if possible.
  #
  # @param timeout [Integer] (3) Seconds to wait before trying the next method.
  # @raise [SubclassResponsibility]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#93
  def stop(timeout = T.unsafe(nil)); end

  # Block until the process has been terminated.
  #
  # @raise [SubclassResponsibility]
  # @return [Integer] The exit status of the process
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#103
  def wait; end

  private

  # @raise [Error]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#187
  def assert_started; end

  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#171
  def detach?; end

  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#175
  def duplex?; end

  # @raise [SubclassResponsibility]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#167
  def launch_process; end

  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/abstract_process.rb#179
  def leader?; end

  # source://childprocess//lib/childprocess/abstract_process.rb#183
  def log(*args); end
end

# source://childprocess//lib/childprocess/abstract_process.rb#3
ChildProcess::AbstractProcess::POLL_INTERVAL = T.let(T.unsafe(nil), Float)

class ChildProcess::Error < ::StandardError; end
class ChildProcess::InvalidEnvironmentVariable < ::ChildProcess::Error; end
class ChildProcess::LaunchError < ::ChildProcess::Error; end

class ChildProcess::MissingFFIError < ::ChildProcess::Error
  # @return [MissingFFIError] a new instance of MissingFFIError
  #
  # source://childprocess//lib/childprocess/errors.rb#18
  def initialize; end
end

class ChildProcess::MissingPlatformError < ::ChildProcess::Error
  # @return [MissingPlatformError] a new instance of MissingPlatformError
  #
  # source://childprocess//lib/childprocess/errors.rb#29
  def initialize; end
end

class ChildProcess::SubclassResponsibility < ::ChildProcess::Error; end
class ChildProcess::TimeoutError < ::ChildProcess::Error; end
module ChildProcess::Unix; end

class ChildProcess::Unix::ForkExecProcess < ::ChildProcess::Unix::Process
  private

  # source://childprocess//lib/childprocess/unix/fork_exec_process.rb#6
  def launch_process; end

  # source://childprocess//lib/childprocess/unix/fork_exec_process.rb#72
  def set_env; end
end

class ChildProcess::Unix::IO < ::ChildProcess::AbstractIO
  private

  # source://childprocess//lib/childprocess/unix/io.rb#6
  def check_type(io); end
end

class ChildProcess::Unix::Process < ::ChildProcess::AbstractProcess
  # @return [Boolean]
  #
  # source://childprocess//lib/childprocess/unix/process.rb#28
  def exited?; end

  # source://childprocess//lib/childprocess/unix/process.rb#6
  def io; end

  # Returns the value of attribute pid.
  #
  # source://childprocess//lib/childprocess/unix/process.rb#4
  def pid; end

  # source://childprocess//lib/childprocess/unix/process.rb#10
  def stop(timeout = T.unsafe(nil)); end

  # source://childprocess//lib/childprocess/unix/process.rb#47
  def wait; end

  private

  # source://childprocess//lib/childprocess/unix/process.rb#80
  def _pid; end

  # source://childprocess//lib/childprocess/unix/process.rb#65
  def send_kill; end

  # source://childprocess//lib/childprocess/unix/process.rb#69
  def send_signal(sig); end

  # source://childprocess//lib/childprocess/unix/process.rb#61
  def send_term; end

  # source://childprocess//lib/childprocess/unix/process.rb#76
  def set_exit_code(status); end
end

# source://childprocess//lib/childprocess/version.rb#2
ChildProcess::VERSION = T.let(T.unsafe(nil), String)

module FFI
  class << self
    # source://ffi/1.15.5/lib/ffi/types.rb#45
    def add_typedef(old, add); end

    # source://ffi/1.15.5/lib/ffi/errno.rb#34
    def errno; end

    # source://ffi/1.15.5/lib/ffi/errno.rb#40
    def errno=(error); end

    # source://ffi/1.15.5/lib/ffi/types.rb#56
    def find_type(name, type_map = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/library.rb#44
    def map_library_name(lib); end

    # source://ffi/1.15.5/lib/ffi/types.rb#176
    def type_size(type); end

    # source://ffi/1.15.5/lib/ffi/types.rb#40
    def typedef(old, add); end
  end
end

class FFI::AbstractMemory
  def [](_arg0); end
  def __copy_from__(_arg0, _arg1); end
  def clear; end
  def get(_arg0, _arg1); end
  def get_array_of_char(_arg0, _arg1); end
  def get_array_of_double(_arg0, _arg1); end
  def get_array_of_float(_arg0, _arg1); end
  def get_array_of_float32(_arg0, _arg1); end
  def get_array_of_float64(_arg0, _arg1); end
  def get_array_of_int(_arg0, _arg1); end
  def get_array_of_int16(_arg0, _arg1); end
  def get_array_of_int32(_arg0, _arg1); end
  def get_array_of_int64(_arg0, _arg1); end
  def get_array_of_int8(_arg0, _arg1); end
  def get_array_of_long(_arg0, _arg1); end
  def get_array_of_long_long(_arg0, _arg1); end
  def get_array_of_pointer(_arg0, _arg1); end
  def get_array_of_short(_arg0, _arg1); end
  def get_array_of_string(*_arg0); end
  def get_array_of_uchar(_arg0, _arg1); end
  def get_array_of_uint(_arg0, _arg1); end
  def get_array_of_uint16(_arg0, _arg1); end
  def get_array_of_uint32(_arg0, _arg1); end
  def get_array_of_uint64(_arg0, _arg1); end
  def get_array_of_uint8(_arg0, _arg1); end
  def get_array_of_ulong(_arg0, _arg1); end
  def get_array_of_ulong_long(_arg0, _arg1); end
  def get_array_of_ushort(_arg0, _arg1); end
  def get_bytes(_arg0, _arg1); end
  def get_char(_arg0); end
  def get_double(_arg0); end
  def get_float(_arg0); end
  def get_float32(_arg0); end
  def get_float64(_arg0); end
  def get_int(_arg0); end
  def get_int16(_arg0); end
  def get_int32(_arg0); end
  def get_int64(_arg0); end
  def get_int8(_arg0); end
  def get_long(_arg0); end
  def get_long_long(_arg0); end
  def get_pointer(_arg0); end
  def get_short(_arg0); end
  def get_string(*_arg0); end
  def get_uchar(_arg0); end
  def get_uint(_arg0); end
  def get_uint16(_arg0); end
  def get_uint32(_arg0); end
  def get_uint64(_arg0); end
  def get_uint8(_arg0); end
  def get_ulong(_arg0); end
  def get_ulong_long(_arg0); end
  def get_ushort(_arg0); end
  def put(_arg0, _arg1, _arg2); end
  def put_array_of_char(_arg0, _arg1); end
  def put_array_of_double(_arg0, _arg1); end
  def put_array_of_float(_arg0, _arg1); end
  def put_array_of_float32(_arg0, _arg1); end
  def put_array_of_float64(_arg0, _arg1); end
  def put_array_of_int(_arg0, _arg1); end
  def put_array_of_int16(_arg0, _arg1); end
  def put_array_of_int32(_arg0, _arg1); end
  def put_array_of_int64(_arg0, _arg1); end
  def put_array_of_int8(_arg0, _arg1); end
  def put_array_of_long(_arg0, _arg1); end
  def put_array_of_long_long(_arg0, _arg1); end
  def put_array_of_pointer(_arg0, _arg1); end
  def put_array_of_short(_arg0, _arg1); end
  def put_array_of_uchar(_arg0, _arg1); end
  def put_array_of_uint(_arg0, _arg1); end
  def put_array_of_uint16(_arg0, _arg1); end
  def put_array_of_uint32(_arg0, _arg1); end
  def put_array_of_uint64(_arg0, _arg1); end
  def put_array_of_uint8(_arg0, _arg1); end
  def put_array_of_ulong(_arg0, _arg1); end
  def put_array_of_ulong_long(_arg0, _arg1); end
  def put_array_of_ushort(_arg0, _arg1); end
  def put_bytes(*_arg0); end
  def put_char(_arg0, _arg1); end
  def put_double(_arg0, _arg1); end
  def put_float(_arg0, _arg1); end
  def put_float32(_arg0, _arg1); end
  def put_float64(_arg0, _arg1); end
  def put_int(_arg0, _arg1); end
  def put_int16(_arg0, _arg1); end
  def put_int32(_arg0, _arg1); end
  def put_int64(_arg0, _arg1); end
  def put_int8(_arg0, _arg1); end
  def put_long(_arg0, _arg1); end
  def put_long_long(_arg0, _arg1); end
  def put_pointer(_arg0, _arg1); end
  def put_short(_arg0, _arg1); end
  def put_string(_arg0, _arg1); end
  def put_uchar(_arg0, _arg1); end
  def put_uint(_arg0, _arg1); end
  def put_uint16(_arg0, _arg1); end
  def put_uint32(_arg0, _arg1); end
  def put_uint64(_arg0, _arg1); end
  def put_uint8(_arg0, _arg1); end
  def put_ulong(_arg0, _arg1); end
  def put_ulong_long(_arg0, _arg1); end
  def put_ushort(_arg0, _arg1); end
  def read_array_of_char(_arg0); end
  def read_array_of_double(_arg0); end
  def read_array_of_float(_arg0); end
  def read_array_of_int(_arg0); end
  def read_array_of_int16(_arg0); end
  def read_array_of_int32(_arg0); end
  def read_array_of_int64(_arg0); end
  def read_array_of_int8(_arg0); end
  def read_array_of_long(_arg0); end
  def read_array_of_long_long(_arg0); end
  def read_array_of_pointer(_arg0); end
  def read_array_of_short(_arg0); end
  def read_array_of_uchar(_arg0); end
  def read_array_of_uint(_arg0); end
  def read_array_of_uint16(_arg0); end
  def read_array_of_uint32(_arg0); end
  def read_array_of_uint64(_arg0); end
  def read_array_of_uint8(_arg0); end
  def read_array_of_ulong(_arg0); end
  def read_array_of_ulong_long(_arg0); end
  def read_array_of_ushort(_arg0); end
  def read_bytes(_arg0); end
  def read_char; end
  def read_double; end
  def read_float; end
  def read_int; end
  def read_int16; end
  def read_int32; end
  def read_int64; end
  def read_int8; end
  def read_long; end
  def read_long_long; end
  def read_pointer; end
  def read_short; end
  def read_uchar; end
  def read_uint; end
  def read_uint16; end
  def read_uint32; end
  def read_uint64; end
  def read_uint8; end
  def read_ulong; end
  def read_ulong_long; end
  def read_ushort; end
  def size; end

  # source://ffi/1.15.5/lib/ffi/abstract_memory.rb#40
  def size_limit?; end

  def total; end
  def type_size; end
  def write_array_of_char(_arg0); end
  def write_array_of_double(_arg0); end
  def write_array_of_float(_arg0); end
  def write_array_of_int(_arg0); end
  def write_array_of_int16(_arg0); end
  def write_array_of_int32(_arg0); end
  def write_array_of_int64(_arg0); end
  def write_array_of_int8(_arg0); end
  def write_array_of_long(_arg0); end
  def write_array_of_long_long(_arg0); end
  def write_array_of_pointer(_arg0); end
  def write_array_of_short(_arg0); end
  def write_array_of_uchar(_arg0); end
  def write_array_of_uint(_arg0); end
  def write_array_of_uint16(_arg0); end
  def write_array_of_uint32(_arg0); end
  def write_array_of_uint64(_arg0); end
  def write_array_of_uint8(_arg0); end
  def write_array_of_ulong(_arg0); end
  def write_array_of_ulong_long(_arg0); end
  def write_array_of_ushort(_arg0); end
  def write_bytes(*_arg0); end
  def write_char(_arg0); end
  def write_double(_arg0); end
  def write_float(_arg0); end
  def write_int(_arg0); end
  def write_int16(_arg0); end
  def write_int32(_arg0); end
  def write_int64(_arg0); end
  def write_int8(_arg0); end
  def write_long(_arg0); end
  def write_long_long(_arg0); end
  def write_pointer(_arg0); end
  def write_short(_arg0); end
  def write_uchar(_arg0); end
  def write_uint(_arg0); end
  def write_uint16(_arg0); end
  def write_uint32(_arg0); end
  def write_uint64(_arg0); end
  def write_uint8(_arg0); end
  def write_ulong(_arg0); end
  def write_ulong_long(_arg0); end
  def write_ushort(_arg0); end
end

class FFI::ArrayType < ::FFI::Type
  def initialize(_arg0, _arg1); end

  def elem_type; end
  def length; end
end

class FFI::AutoPointer < ::FFI::Pointer
  extend ::FFI::DataConverter

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#78
  def initialize(ptr, proc = T.unsafe(nil), &block); end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#109
  def autorelease=(autorelease); end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#115
  def autorelease?; end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#102
  def free; end

  class << self
    # source://ffi/1.15.5/lib/ffi/autopointer.rb#198
    def from_native(val, ctx); end

    # source://ffi/1.15.5/lib/ffi/autopointer.rb#184
    def native_type; end
  end
end

class FFI::AutoPointer::CallableReleaser < ::FFI::AutoPointer::Releaser
  # source://ffi/1.15.5/lib/ffi/autopointer.rb#174
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser < ::FFI::AutoPointer::Releaser
  # source://ffi/1.15.5/lib/ffi/autopointer.rb#161
  def release(ptr); end
end

class FFI::AutoPointer::Releaser
  # source://ffi/1.15.5/lib/ffi/autopointer.rb#130
  def initialize(ptr, proc); end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#124
  def autorelease; end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#124
  def autorelease=(_arg0); end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#149
  def call(*args); end

  # source://ffi/1.15.5/lib/ffi/autopointer.rb#138
  def free; end
end

class FFI::Bitmask < ::FFI::Enum
  # source://ffi/1.15.5/lib/ffi/enum.rb#193
  def initialize(*args); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#236
  def [](*query); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#282
  def from_native(val, ctx); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#260
  def to_native(query, ctx); end
end

class FFI::Buffer < ::FFI::AbstractMemory
  def initialize(*_arg0); end

  def +(_arg0); end
  def inspect; end
  def length; end
  def order(*_arg0); end
  def slice(_arg0, _arg1); end

  private

  def initialize_copy(_arg0); end

  class << self
    def alloc_in(*_arg0); end
    def alloc_inout(*_arg0); end
    def alloc_out(*_arg0); end
    def new_in(*_arg0); end
    def new_inout(*_arg0); end
    def new_out(*_arg0); end
  end
end

# source://ffi/1.15.5/lib/ffi/library.rb#32
FFI::CURRENT_PROCESS = T.let(T.unsafe(nil), Object)

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  # source://ffi/1.15.5/lib/ffi/data_converter.rb#63
  def from_native(value, ctx); end

  # source://ffi/1.15.5/lib/ffi/data_converter.rb#45
  def native_type(type = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/data_converter.rb#58
  def to_native(value, ctx); end
end

class FFI::DynamicLibrary
  def initialize(_arg0, _arg1); end

  def find_function(_arg0); end
  def find_symbol(_arg0); end
  def find_variable(_arg0); end
  def last_error; end
  def name; end

  class << self
    def last_error; end
    def open(_arg0, _arg1); end
  end
end

FFI::DynamicLibrary::RTLD_ALL_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_BINDING_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_DEEPBIND = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_FIRST = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_GLOBAL = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LAZY = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LOCAL = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LOCATION_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_MEMBER = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NODELETE = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NOLOAD = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NOW = T.let(T.unsafe(nil), Integer)

class FFI::DynamicLibrary::Symbol < ::FFI::Pointer
  def inspect; end

  private

  def initialize_copy(_arg0); end
end

class FFI::Enum
  include ::FFI::DataConverter

  # source://ffi/1.15.5/lib/ffi/enum.rb#97
  def initialize(*args); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#134
  def [](query); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#134
  def find(query); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#168
  def from_native(val, ctx); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#88
  def native_type; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#146
  def symbol_map; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#121
  def symbols; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#87
  def tag; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#146
  def to_h; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#146
  def to_hash; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#156
  def to_native(val, ctx); end
end

class FFI::Enums
  # source://ffi/1.15.5/lib/ffi/enum.rb#39
  def initialize; end

  # source://ffi/1.15.5/lib/ffi/enum.rb#47
  def <<(enum); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#66
  def __map_symbol(symbol); end

  # source://ffi/1.15.5/lib/ffi/enum.rb#56
  def find(query); end
end

class FFI::Function < ::FFI::Pointer
  def initialize(*_arg0); end

  def attach(_arg0, _arg1); end
  def autorelease; end
  def autorelease=(_arg0); end
  def autorelease?; end
  def call(*_arg0); end
  def free; end

  private

  def initialize_copy(_arg0); end
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType < ::FFI::Type
  def initialize(*_arg0); end

  def param_types; end
  def result_type; end
end

module FFI::IO
  class << self
    # source://ffi/1.15.5/lib/ffi/io.rb#39
    def for_fd(fd, mode = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/io.rb#53
    def native_read(io, buf, len); end
  end
end

module FFI::LastError
  private

  def error; end
  def error=(_arg0); end

  class << self
    def error; end
    def error=(_arg0); end
  end
end

module FFI::Library
  # source://ffi/1.15.5/lib/ffi/library.rb#234
  def attach_function(name, func, args, returns = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/library.rb#331
  def attach_variable(mname, a1, a2 = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/library.rb#554
  def bitmask(*args); end

  # source://ffi/1.15.5/lib/ffi/library.rb#384
  def callback(*args); end

  # source://ffi/1.15.5/lib/ffi/library.rb#511
  def enum(*args); end

  # source://ffi/1.15.5/lib/ffi/library.rb#561
  def enum_type(name); end

  # source://ffi/1.15.5/lib/ffi/library.rb#568
  def enum_value(symbol); end

  # source://ffi/1.15.5/lib/ffi/library.rb#163
  def ffi_convention(convention = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/library.rb#95
  def ffi_lib(*names); end

  # source://ffi/1.15.5/lib/ffi/library.rb#196
  def ffi_lib_flags(*flags); end

  # source://ffi/1.15.5/lib/ffi/library.rb#173
  def ffi_libraries; end

  # source://ffi/1.15.5/lib/ffi/library.rb#575
  def find_type(t); end

  # source://ffi/1.15.5/lib/ffi/library.rb#289
  def function_names(name, arg_types); end

  # source://ffi/1.15.5/lib/ffi/library.rb#428
  def typedef(old, add, info = T.unsafe(nil)); end

  private

  # source://ffi/1.15.5/lib/ffi/library.rb#456
  def generic_enum(klass, *args); end

  class << self
    # source://ffi/1.15.5/lib/ffi/library.rb#86
    def extended(mod); end
  end
end

# source://ffi/1.15.5/lib/ffi/library.rb#79
FFI::Library::CURRENT_PROCESS = T.let(T.unsafe(nil), Object)

# source://ffi/1.15.5/lib/ffi/library.rb#182
FFI::Library::FlagsMap = T.let(T.unsafe(nil), Hash)

# source://ffi/1.15.5/lib/ffi/library.rb#80
FFI::Library::LIBC = T.let(T.unsafe(nil), String)

class FFI::ManagedStruct < ::FFI::Struct
  # source://ffi/1.15.5/lib/ffi/managedstruct.rb#77
  def initialize(pointer = T.unsafe(nil)); end
end

# missing on rubinius
class FFI::MemoryPointer < ::FFI::Pointer
  def initialize(*_arg0); end

  class << self
    def from_string(_arg0); end
  end
end

FFI::NativeLibrary = FFI::DynamicLibrary
module FFI::NativeType; end
FFI::NativeType::BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::NotFoundError < ::LoadError
  # source://ffi/1.15.5/lib/ffi/library.rb#59
  def initialize(function, *libraries); end
end

class FFI::NullPointerError < ::RuntimeError; end

module FFI::Platform
  class << self
    # source://ffi/1.15.5/lib/ffi/platform.rb#156
    def bsd?; end

    # source://ffi/1.15.5/lib/ffi/platform.rb#90
    def is_os(os); end

    # source://ffi/1.15.5/lib/ffi/platform.rb#168
    def mac?; end

    # source://ffi/1.15.5/lib/ffi/platform.rb#174
    def solaris?; end

    # source://ffi/1.15.5/lib/ffi/platform.rb#180
    def unix?; end

    # source://ffi/1.15.5/lib/ffi/platform.rb#162
    def windows?; end
  end
end

FFI::Platform::ADDRESS_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::ADDRESS_SIZE = T.let(T.unsafe(nil), Integer)

# source://ffi/1.15.5/lib/ffi/platform.rb#63
FFI::Platform::ARCH = T.let(T.unsafe(nil), String)

FFI::Platform::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
FFI::Platform::BYTE_ORDER = T.let(T.unsafe(nil), Integer)

# source://ffi/1.15.5/lib/ffi/platform.rb#109
FFI::Platform::CONF_DIR = T.let(T.unsafe(nil), String)

# source://ffi/1.15.5/lib/ffi/platform.rb#61
FFI::Platform::CPU = T.let(T.unsafe(nil), String)

FFI::Platform::DOUBLE_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::DOUBLE_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::FLOAT_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::FLOAT_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT16_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT16_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT32_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT32_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT64_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT64_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT8_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT8_SIZE = T.let(T.unsafe(nil), Integer)

# source://ffi/1.15.5/lib/ffi/platform.rb#103
FFI::Platform::IS_BSD = T.let(T.unsafe(nil), TrueClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#100
FFI::Platform::IS_DRAGONFLYBSD = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#97
FFI::Platform::IS_FREEBSD = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#94
FFI::Platform::IS_GNU = T.let(T.unsafe(nil), T.untyped)

# source://ffi/1.15.5/lib/ffi/platform.rb#95
FFI::Platform::IS_LINUX = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#96
FFI::Platform::IS_MAC = T.let(T.unsafe(nil), TrueClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#98
FFI::Platform::IS_NETBSD = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#99
FFI::Platform::IS_OPENBSD = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#101
FFI::Platform::IS_SOLARIS = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#102
FFI::Platform::IS_WINDOWS = T.let(T.unsafe(nil), FalseClass)

# source://ffi/1.15.5/lib/ffi/platform.rb#134
FFI::Platform::LIBC = T.let(T.unsafe(nil), String)

# source://ffi/1.15.5/lib/ffi/platform.rb#113
FFI::Platform::LIBPREFIX = T.let(T.unsafe(nil), String)

# source://ffi/1.15.5/lib/ffi/platform.rb#122
FFI::Platform::LIBSUFFIX = T.let(T.unsafe(nil), String)

FFI::Platform::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_DOUBLE_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_DOUBLE_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_SIZE = T.let(T.unsafe(nil), Integer)

# source://ffi/1.15.5/lib/ffi/platform.rb#108
FFI::Platform::NAME = T.let(T.unsafe(nil), String)

# source://ffi/1.15.5/lib/ffi/platform.rb#38
FFI::Platform::OS = T.let(T.unsafe(nil), String)

# source://ffi/1.15.5/lib/ffi/platform.rb#59
FFI::Platform::OSVERSION = T.let(T.unsafe(nil), Integer)

class FFI::PlatformError < ::LoadError; end

class FFI::Pointer < ::FFI::AbstractMemory
  def initialize(*_arg0); end

  def +(_arg0); end
  def ==(_arg0); end
  def address; end
  def autorelease=(_arg0); end
  def autorelease?; end
  def free; end
  def inspect; end
  def null?; end
  def order(*_arg0); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#152
  def read(type); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#114
  def read_array_of_type(type, reader, length); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#57
  def read_string(len = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#72
  def read_string_length(len); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#81
  def read_string_to_null; end

  def slice(_arg0, _arg1); end
  def to_i; end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#142
  def to_ptr; end

  def to_s; end
  def type_size; end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#163
  def write(type, value); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#132
  def write_array_of_type(type, writer, ary); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#101
  def write_string(str, len = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/pointer.rb#92
  def write_string_length(str, len); end

  private

  def initialize_copy(_arg0); end

  class << self
    # source://ffi/1.15.5/lib/ffi/pointer.rb#49
    def size; end
  end
end

FFI::Pointer::NULL = T.let(T.unsafe(nil), FFI::Pointer)

# source://ffi/1.15.5/lib/ffi/pointer.rb#45
FFI::Pointer::SIZE = T.let(T.unsafe(nil), Integer)

FFI::SizeTypes = T.let(T.unsafe(nil), Hash)

class FFI::StrPtrConverter
  extend ::FFI::DataConverter

  class << self
    # source://ffi/1.15.5/lib/ffi/types.rb#166
    def from_native(val, ctx); end
  end
end

class FFI::Struct
  def initialize(*_arg0); end

  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # source://ffi/1.15.5/lib/ffi/struct.rb#50
  def align; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#50
  def alignment; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#78
  def clear; end

  def layout; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#61
  def members; end

  def null?; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#56
  def offset_of(name); end

  # source://ffi/1.15.5/lib/ffi/struct.rb#72
  def offsets; end

  def order(*_arg0); end
  def pointer; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#45
  def size; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#85
  def to_ptr; end

  # source://ffi/1.15.5/lib/ffi/struct.rb#67
  def values; end

  private

  def initialize_copy(_arg0); end
  def layout=(_arg0); end
  def pointer=(_arg0); end

  class << self
    # source://ffi/1.15.5/lib/ffi/struct.rb#104
    def alignment; end

    def alloc_in(*_arg0); end
    def alloc_inout(*_arg0); end
    def alloc_out(*_arg0); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#165
    def auto_ptr; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#143
    def by_ref(flags = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#139
    def by_value; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#123
    def in; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#205
    def layout(*spec); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#109
    def members; end

    def new_in(*_arg0); end
    def new_inout(*_arg0); end
    def new_out(*_arg0); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#119
    def offset_of(name); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#114
    def offsets; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#127
    def out; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#131
    def ptr(flags = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#91
    def size; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#98
    def size=(size); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#135
    def val; end

    protected

    # source://ffi/1.15.5/lib/ffi/struct.rb#243
    def align(alignment = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#243
    def aligned(alignment = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#229
    def callback(params, ret); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#248
    def enclosing_module; end

    # source://ffi/1.15.5/lib/ffi/struct.rb#260
    def find_field_type(type, mod = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#275
    def find_type(type, mod = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#238
    def pack(packed = T.unsafe(nil)); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#238
    def packed(packed = T.unsafe(nil)); end

    private

    # source://ffi/1.15.5/lib/ffi/struct.rb#297
    def array_layout(builder, spec); end

    # source://ffi/1.15.5/lib/ffi/struct.rb#287
    def hash_layout(builder, spec); end
  end
end

class FFI::Struct::InlineArray
  include ::Enumerable

  def initialize(_arg0, _arg1); end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def each; end
  def size; end
  def to_a; end
  def to_ptr; end
end

class FFI::Struct::ManagedStructConverter < ::FFI::StructByReference
  # source://ffi/1.15.5/lib/ffi/struct.rb#150
  def initialize(struct_class); end

  # source://ffi/1.15.5/lib/ffi/struct.rb#160
  def from_native(ptr, ctx); end
end

class FFI::StructByReference
  include ::FFI::DataConverter

  # source://ffi/1.15.5/lib/ffi/struct_by_reference.rb#39
  def initialize(struct_class); end

  # source://ffi/1.15.5/lib/ffi/struct_by_reference.rb#68
  def from_native(value, ctx); end

  # source://ffi/1.15.5/lib/ffi/struct_by_reference.rb#47
  def native_type; end

  # source://ffi/1.15.5/lib/ffi/struct_by_reference.rb#36
  def struct_class; end

  # source://ffi/1.15.5/lib/ffi/struct_by_reference.rb#54
  def to_native(value, ctx); end
end

class FFI::StructByValue < ::FFI::Type
  def initialize(_arg0); end

  def layout; end
  def struct_class; end
end

class FFI::StructLayout < ::FFI::Type
  def initialize(_arg0, _arg1, _arg2); end

  def [](_arg0); end
  def __union!; end
  def fields; end
  def members; end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#46
  def offset_of(field_name); end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#40
  def offsets; end

  def to_a; end
end

class FFI::StructLayout::Array < ::FFI::StructLayout::Field
  def get(_arg0); end
  def put(_arg0, _arg1); end
end

class FFI::StructLayout::CharArray < ::FFI::Struct::InlineArray
  def to_s; end
  def to_str; end
end

class FFI::StructLayout::Enum < ::FFI::StructLayout::Field
  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#56
  def get(ptr); end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#64
  def put(ptr, value); end
end

class FFI::StructLayout::Field
  def initialize(*_arg0); end

  def alignment; end
  def get(_arg0); end
  def name; end
  def offset; end
  def put(_arg0, _arg1); end
  def size; end
  def type; end
end

class FFI::StructLayout::Function < ::FFI::StructLayout::Field
  def get(_arg0); end
  def put(_arg0, _arg1); end
end

class FFI::StructLayout::InnerStruct < ::FFI::StructLayout::Field
  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#71
  def get(ptr); end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#75
  def put(ptr, value); end
end

class FFI::StructLayout::Mapped < ::FFI::StructLayout::Field
  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#82
  def initialize(name, offset, type, orig_field); end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#87
  def get(ptr); end

  # source://ffi/1.15.5/lib/ffi/struct_layout.rb#91
  def put(ptr, value); end
end

class FFI::StructLayout::Number < ::FFI::StructLayout::Field; end
class FFI::StructLayout::Pointer < ::FFI::StructLayout::Field; end
class FFI::StructLayout::String < ::FFI::StructLayout::Field; end

class FFI::StructLayoutBuilder
  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#39
  def initialize; end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#123
  def add(name, type, offset = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#161
  def add_array(name, type, count, offset = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#144
  def add_field(name, type, offset = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#151
  def add_struct(name, type, offset = T.unsafe(nil)); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#37
  def alignment; end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#56
  def alignment=(align); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#167
  def build; end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#89
  def packed=(packed); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#36
  def size; end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#50
  def size=(size); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#65
  def union=(is_union); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#73
  def union?; end

  private

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#181
  def align(offset, align); end

  # source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#187
  def field_for_type(name, offset, type); end
end

# source://ffi/1.15.5/lib/ffi/struct_layout_builder.rb#100
FFI::StructLayoutBuilder::NUMBER_TYPES = T.let(T.unsafe(nil), Array)

FFI::TYPE_BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type
  def initialize(_arg0); end

  def alignment; end
  def inspect; end
  def size; end
end

FFI::Type::Array = FFI::ArrayType
FFI::Type::BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type::Builtin < ::FFI::Type
  def inspect; end
end

FFI::Type::CHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::DOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::Function = FFI::FunctionType
FFI::Type::INT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type::Mapped < ::FFI::Type
  def initialize(_arg0); end

  def from_native(*_arg0); end
  def native_type; end
  def to_native(*_arg0); end
  def type; end
end

FFI::Type::POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SCHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SINT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SLONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SLONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SSHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::Struct = FFI::StructByValue
FFI::Type::UCHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::ULONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::USHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TypeDefs = T.let(T.unsafe(nil), Hash)

# source://ffi/1.15.5/lib/ffi/library.rb#32
FFI::USE_THIS_PROCESS_AS_LIBRARY = T.let(T.unsafe(nil), Object)

class FFI::Union < ::FFI::Struct
  class << self
    # source://ffi/1.15.5/lib/ffi/union.rb#37
    def builder; end
  end
end

# source://ffi/1.15.5/lib/ffi/version.rb#2
FFI::VERSION = T.let(T.unsafe(nil), String)

class FFI::VariadicInvoker
  def initialize(_arg0, _arg1, _arg2, _arg3); end

  # source://ffi/1.15.5/lib/ffi/variadic.rb#53
  def attach(mod, mname); end

  # source://ffi/1.15.5/lib/ffi/variadic.rb#35
  def call(*args, &block); end

  def invoke(_arg0, _arg1); end
end
