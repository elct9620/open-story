# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-logger` gem.
# Please instead update this file by running `bin/tapioca gem dry-logger`.

# source://dry-logger//lib/dry/logger/global.rb#5
module Dry
  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject.rb#61
    def AutoInject(container, options = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli.rb#221
    def CLI(registry_or_command = T.unsafe(nil), &block); end

    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.0.0/lib/dry/core.rb#41
    def Equalizer(*keys, **options); end

    # Set up a logger dispatcher
    #
    # @api public
    # @example Customized $stdout string logger
    #   logger = Dry.Logger(:my_app, template: "[%<severity>][%<time>s] %<message>s")
    #
    #   logger.info("Hello World!")
    #   # [INFO][2022-11-06 10:55:12 +0100] Hello World!
    #
    #   logger.info(Hello: "World!")
    #   # [INFO][2022-11-06 10:55:14 +0100] Hello="World!"
    #
    #   logger.warn("Ooops!")
    #   # [WARN][2022-11-06 10:55:57 +0100] Ooops!
    #
    #   logger.error("Gaaah!")
    #   # [ERROR][2022-11-06 10:55:57 +0100] Gaaah!
    # @example Basic $stdout JSON logger
    #   logger = Dry.Logger(:my_app, formatter: :json)
    #
    #   logger.info(Hello: "World!")
    #   # {"progname":"my_app","severity":"INFO","time":"2022-11-06T10:11:29Z","Hello":"World!"}
    # @example Setting up multiple backends
    #   logger = Dry.Logger(:my_app)
    #   add_backend(formatter: :string, template: :details)
    #   add_backend(formatter: :string, template: :details)
    # @example Setting up conditional logging
    #   logger = Dry.Logger(:my_app) { |setup|
    #   setup.add_backend(formatter: :string, template: :details) { |b| b.log_if = :error?.to_proc }
    #   }
    # @example Basic $stdout string logger
    #   logger = Dry.Logger(:my_app)
    #
    #   logger.info("Hello World!")
    #   # Hello World!
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param id [String, Symbol] The dispatcher id, can be used as progname in log entries
    # @param options [Hash] Options for backends and formatters
    # @return [Dispatcher]
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger.rb#73
    def Logger(id, **options, &block); end

    # source://dry-struct/1.6.0/lib/dry/struct.rb#30
    def Struct(attributes = T.unsafe(nil), &block); end

    # source://dry-types/1.7.0/lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-logger//lib/dry/logger/global.rb#6
module Dry::Logger
  extend ::Dry::Logger::Global
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#33
Dry::Logger::BACKEND_METHODS = T.let(T.unsafe(nil), Array)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#89
Dry::Logger::BACKEND_OPT_KEYS = T.let(T.unsafe(nil), Array)

# source://dry-logger//lib/dry/logger/backends/core.rb#7
module Dry::Logger::Backends; end

# source://dry-logger//lib/dry/logger/backends/core.rb#8
module Dry::Logger::Backends::Core
  # @api private
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/core.rb#28
  def log?(entry); end

  # Return a proc used by the log? predicate
  #
  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/core.rb#13
  def log_if; end

  # Set a predicate proc that checks if an entry should be logged by a given backend
  #
  # The predicate will receive {Entry} as its argument and should return true/false
  #
  # @api public
  # @param spec [Proc, #to_proc] A proc-like object
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/core.rb#22
  def log_if=(spec); end
end

# source://dry-logger//lib/dry/logger/backends/file.rb#10
class Dry::Logger::Backends::File < ::Dry::Logger::Backends::Stream
  # @return [File] a new instance of File
  #
  # source://dry-logger//lib/dry/logger/backends/file.rb#11
  def initialize(stream:, **opts); end
end

# source://dry-logger//lib/dry/logger/backends/io.rb#8
class Dry::Logger::Backends::IO < ::Dry::Logger::Backends::Stream
  # source://dry-logger//lib/dry/logger/backends/io.rb#9
  def close; end
end

# Logger proxy is used for regular loggers that don't work with log entries
#
# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/backends/proxy.rb#15
class Dry::Logger::Backends::Proxy < ::SimpleDelegator
  include ::Dry::Logger::Backends::Core

  # @api private
  # @return [Proxy] a new instance of Proxy
  # @since 1.0.2
  #
  # source://dry-logger//lib/dry/logger/backends/proxy.rb#40
  def initialize(backend, **options); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def debug(entry); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def error(entry); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def fatal(entry); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def info(entry); end

  # @api private
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/proxy.rb#48
  def log?(entry); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def unknown(entry); end

  # source://dry-logger//lib/dry/logger/backends/proxy.rb#19
  def warn(entry); end

  private

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/proxy.rb#67
  def __supported_methods__; end

  # @api private
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/proxy.rb#60
  def __supports_payload__?(method); end
end

# source://dry-logger//lib/dry/logger/backends/stream.rb#11
class Dry::Logger::Backends::Stream < ::Logger
  include ::Dry::Logger::Backends::Core

  # @api private
  # @return [Stream] a new instance of Stream
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/backends/stream.rb#24
  def initialize(stream:, formatter:, level: T.unsafe(nil), progname: T.unsafe(nil), log_if: T.unsafe(nil)); end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/backends/stream.rb#36
  def inspect; end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/backends/stream.rb#20
  def level; end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/backends/stream.rb#16
  def stream; end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/clock.rb#7
class Dry::Logger::Clock
  # @api private
  # @return [Clock] a new instance of Clock
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#14
  def initialize(unit: T.unsafe(nil)); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#32
  def measure; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#20
  def now; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#26
  def now_utc; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#10
  def unit; end

  private

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/clock.rb#42
  def current; end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#37
Dry::Logger::DEBUG = T.let(T.unsafe(nil), Integer)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#65
Dry::Logger::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#85
Dry::Logger::DEFAULT_OPTS = T.let(T.unsafe(nil), Hash)

# Logger dispatcher routes log entries to configured logging backends
#
# @api public
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/dispatcher.rb#16
class Dry::Logger::Dispatcher
  # @api private
  # @return [Dispatcher] a new instance of Dispatcher
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#95
  def initialize(id, backends: T.unsafe(nil), tags: T.unsafe(nil), context: T.unsafe(nil), **options); end

  # Add a new backend to an existing dispatcher
  #
  # @api public
  # @example
  #   logger.add_backend(template: "ERROR: %<message>s") { |b|
  #   b.log_if = -> entry { entry.error? }
  #   }
  # @return [Dispatcher]
  # @since 1.0.0
  # @yield [backend]
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#259
  def add_backend(instance = T.unsafe(nil), **backend_options); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#35
  def backends; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#43
  def clock; end

  # source://dry-logger//lib/dry/logger/dispatcher.rb#163
  def close; end

  # (EXPERIMENTAL) Shared payload context
  #
  # @api public
  # @example
  #   logger.context[:component] = "test"
  #
  #   logger.info "Hello World"
  #   # Hello World component=test
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#31
  def context; end

  # Log an entry with DEBUG severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#122
  def debug(message = T.unsafe(nil), **payload); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#280
  def each_backend(&block); end

  # Log an entry with ERROR severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#149
  def error(message = T.unsafe(nil), **payload); end

  # Log an entry with FATAL severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#158
  def fatal(message = T.unsafe(nil), **payload); end

  # Pass logging to all configured backends
  #
  # @api private
  # @return [true]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#291
  def forward(meth, *_arg1, **_arg2, &_arg3); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#19
  def id; end

  # Log an entry with INFO severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#131
  def info(message = T.unsafe(nil), **payload); end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#274
  def inspect; end

  # Return severity level
  #
  # @api public
  # @return [Integer]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#173
  def level; end

  # Pass logging to all configured backends
  #
  # @api public
  # @example logging a message
  #   logger.log(:info, "Hello World")
  # @example logging payload
  #   logger.log(:info, verb: "GET", path: "/users")
  # @example logging message and payload
  #   logger.log(:info, "User index request", verb: "GET", path: "/users")
  # @example logging exception
  #   begin
  #   # things that may raise
  #   rescue => e
  #   logger.log(:error, e)
  #   raise e
  #   end
  # @param severity [Symbol] The log severity name
  # @param message [String] Optional message
  # @param payload [Hash] Optional log entry payload
  # @return [true]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#203
  def log(severity, message = T.unsafe(nil), **payload); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#51
  def mutex; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#47
  def on_crash; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#39
  def options; end

  # (EXPERIMENTAL) Tagged logging withing the provided block
  #
  # @api public
  # @example
  #   logger.tagged("red") do
  #   logger.info "Hello World"
  #   # Hello World tag=red
  #   end
  #
  #   logger.info "Hello Again"
  #   # Hello Again
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#242
  def tagged(*tags); end

  # Log an entry with UNKNOWN severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#113
  def unknown(message = T.unsafe(nil), **payload); end

  # Log an entry with WARN severity
  #
  # @api public
  # @return [true]
  # @see Dispatcher#log
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/dispatcher.rb#140
  def warn(message = T.unsafe(nil), **payload); end

  class << self
    # @api private
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/dispatcher.rb#89
    def default_context; end

    # Set up a dispatcher
    #
    # @api private
    # @return [Dispatcher]
    # @since 1.0.0
    # @yield [dispatcher]
    #
    # source://dry-logger//lib/dry/logger/dispatcher.rb#80
    def setup(id, **options); end
  end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/dispatcher.rb#55
Dry::Logger::Dispatcher::CRASH_LOGGER = T.let(T.unsafe(nil), Logger)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/dispatcher.rb#62
Dry::Logger::Dispatcher::ON_CRASH = T.let(T.unsafe(nil), Proc)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#21
Dry::Logger::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#25
Dry::Logger::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#49
Dry::Logger::ERROR = T.let(T.unsafe(nil), Integer)

# @api public
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/entry.rb#10
class Dry::Logger::Entry
  include ::Enumerable

  # @api private
  # @return [Entry] a new instance of Entry
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#48
  def initialize(clock:, progname:, severity:, tags: T.unsafe(nil), message: T.unsafe(nil), payload: T.unsafe(nil)); end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#69
  def [](name); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#43
  def clock; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#75
  def debug?; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#63
  def each(&block); end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#93
  def error?; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#35
  def exception; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#105
  def exception?; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#99
  def fatal?; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#135
  def filter(filter); end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#81
  def info?; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#111
  def key?(name); end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#27
  def level; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#31
  def message; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#123
  def meta; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#39
  def payload; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#15
  def progname; end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#19
  def severity; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#117
  def tag?(value); end

  # @api public
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#23
  def tags; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#129
  def to_h; end

  # @api public
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#87
  def warn?; end

  private

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/entry.rb#144
  def build_payload(payload); end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#53
Dry::Logger::FATAL = T.let(T.unsafe(nil), Integer)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#93
Dry::Logger::FORMATTER_OPT_KEYS = T.let(T.unsafe(nil), Array)

# Filtering logic
# Originaly copied from hanami/utils (see Hanami::Logger)
#
# @api private
# @since 0.1.0
#
# source://dry-logger//lib/dry/logger/filter.rb#10
class Dry::Logger::Filter
  # @api private
  # @return [Filter] a new instance of Filter
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#13
  def initialize(filters = T.unsafe(nil)); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#19
  def call(hash); end

  private

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#60
  def _actual_keys(hash, keys); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#54
  def _build_path(base, key); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#36
  def _filtered_keys(hash); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#46
  def _key_paths(hash, base = T.unsafe(nil)); end

  # Check if the given value can be iterated (`Enumerable`) and that isn't a `File`.
  # This is useful to detect closed `Tempfiles`.
  #
  # @api private
  # @return [Boolean]
  # @see https://github.com/hanami/utils/pull/342
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#77
  def _key_paths?(value); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/filter.rb#32
  def filters; end
end

# source://dry-logger//lib/dry/logger/formatters/colors.rb#5
module Dry::Logger::Formatters; end

# Shell colorizer
#
# This was ported from hanami-utils
#
# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/colors.rb#12
class Dry::Logger::Formatters::Colors
  class << self
    # Helper method to translate between color names and terminal escape codes
    #
    # @api private
    # @raise [UnknownColorError] if the color code is unknown
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/colors.rb#78
    def [](code); end

    # Colorizes output
    # 8 colors available: black, red, green, yellow, blue, magenta, cyan, and gray
    #
    # @api private
    # @param input [#to_s] the string to colorize
    # @param color [Symbol] the color
    # @raise [UnknownColorError] if the color code is unknown
    # @return [String] the colorized string
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/colors.rb#56
    def call(color, input); end

    # @api private
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/colors.rb#36
    def evaluate(input); end

    # @api private
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/colors.rb#62
    def start(color); end

    # @api private
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/colors.rb#68
    def stop; end
  end
end

# Escapes codes for terminals to output strings in colors
#
# @api private
# @since 1.2.0
#
# source://dry-logger//lib/dry/logger/formatters/colors.rb#26
Dry::Logger::Formatters::Colors::COLORS = T.let(T.unsafe(nil), Hash)

# Unknown color code error
#
# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/colors.rb#16
class Dry::Logger::Formatters::Colors::UnknownColorCodeError < ::StandardError
  # @api private
  # @return [UnknownColorCodeError] a new instance of UnknownColorCodeError
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/colors.rb#17
  def initialize(code); end
end

# JSON formatter.
#
# This formatter returns log entries in JSON format.
#
# @api public
# @since 0.1.0
#
# source://dry-logger//lib/dry/logger/formatters/json.rb#19
class Dry::Logger::Formatters::JSON < ::Dry::Logger::Formatters::Structured
  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/formatters/json.rb#20
  def format(entry); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/formatters/json.rb#34
  def format_exception(value); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/formatters/json.rb#28
  def format_severity(value); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-logger//lib/dry/logger/formatters/json.rb#44
  def format_time(value); end
end

# Special handling of `:params` in the log entry payload
#
# @api private
# @see String
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/rack.rb#17
class Dry::Logger::Formatters::Rack < ::Dry::Logger::Formatters::String
  # @api private
  # @return [Rack] a new instance of Rack
  # @see String#initialize
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/rack.rb#18
  def initialize(**options); end

  # @api 1.0.0
  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/rack.rb#25
  def format_params(value); end
end

# Basic string formatter.
#
# This formatter returns log entries in key=value format.
#
# @api public
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/string.rb#19
class Dry::Logger::Formatters::String < ::Dry::Logger::Formatters::Structured
  # @api private
  # @return [String] a new instance of String
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#43
  def initialize(template: T.unsafe(nil), **options); end

  # @api private
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#50
  def colorize?; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#39
  def template; end

  private

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#70
  def format(entry); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#112
  def format_backtrace(value); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#97
  def format_exception(value); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#106
  def format_payload(payload); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#58
  def format_severity(value); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#83
  def format_tags(value); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#140
  def severity_colors; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/string.rb#118
  def template_data(entry, exclude: T.unsafe(nil)); end
end

# @api private
# @since 1.2.0
#
# source://dry-logger//lib/dry/logger/formatters/string.rb#28
Dry::Logger::Formatters::String::DEFAULT_SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/string.rb#24
Dry::Logger::Formatters::String::EXCEPTION_SEPARATOR = T.let(T.unsafe(nil), String)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/string.rb#20
Dry::Logger::Formatters::String::HASH_SEPARATOR = T.let(T.unsafe(nil), String)

# Default structured formatter which receives {Logger::Entry} from the backends.
#
# This class can be used as the base class for your custom formatters.
#
# @api public
# @see http://www.ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Formatter.html
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/structured.rb#21
class Dry::Logger::Formatters::Structured < ::Logger::Formatter
  # @api private
  # @return [Structured] a new instance of Structured
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#38
  def initialize(filters: T.unsafe(nil), **options); end

  # Filter and then format the log entry into a string
  #
  # Custom formatters typically won't have to override this method because
  # the actual formatting logic is implemented as Structured#format
  #
  # @api public
  # @return [String]
  # @see http://www.ruby-doc.org/stdlib/libdoc/logger/rdoc/Logger/Formatter.html#method-i-call
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#54
  def call(_severity, _time, _progname, entry); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#30
  def filter; end

  # Format entry into a loggable object
  #
  # Custom formatters should override this method
  #
  # @api since 1.0.0
  # @api public
  # @return [Entry]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#65
  def format(entry); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#71
  def format_values(entry); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/structured.rb#34
  def options; end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/structured.rb#22
Dry::Logger::Formatters::Structured::DEFAULT_FILTERS = T.let(T.unsafe(nil), Array)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/structured.rb#26
Dry::Logger::Formatters::Structured::NOOP_FILTER = T.let(T.unsafe(nil), Proc)

# Basic string formatter.
#
# This formatter returns log entries in key=value format.
#
# @api public
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/template.rb#16
class Dry::Logger::Formatters::Template
  # @api private
  # @return [Template] a new instance of Template
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#65
  def initialize(value); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#72
  def %(tokens); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#80
  def colorize(color, input); end

  # @api private
  # @return [Boolean]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#86
  def include?(token); end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#31
  def tokens; end

  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#27
  def value; end

  class << self
    # @api private
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/template.rb#35
    def [](value); end

    private

    # @api private
    # @api public
    # @since 1.0.0
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/template.rb#49
    def cache; end

    # @api private
    # @api public
    # @return [Boolean]
    # @since 1.0.0
    # @since 1.0.0
    #
    # source://dry-logger//lib/dry/logger/formatters/template.rb#43
    def colorized?(value); end
  end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/template.rb#57
class Dry::Logger::Formatters::Template::Colorized < ::Dry::Logger::Formatters::Template
  # @api private
  # @return [Colorized] a new instance of Colorized
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/formatters/template.rb#58
  def initialize(value); end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/template.rb#23
Dry::Logger::Formatters::Template::MESSAGE_TOKEN = T.let(T.unsafe(nil), String)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/formatters/template.rb#19
Dry::Logger::Formatters::Template::TOKEN_REGEXP = T.let(T.unsafe(nil), Regexp)

# Global setup methods
#
# @api public
#
# source://dry-logger//lib/dry/logger/global.rb#10
module Dry::Logger::Global
  # Internal formatters registry
  #
  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/global.rb#110
  def formatters; end

  # Build a logging backend instance
  #
  # @api private
  # @return [Backends::Stream]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/global.rb#67
  def new(stream: T.unsafe(nil), **options); end

  # Register a new formatter
  #
  # @api public
  # @example
  #   class MyFormatter < Dry::Logger::Formatters::Structured
  #   def format_message(value)
  #   "WOAH: #{message}"
  #   end
  #
  #   def format_time(value)
  #   Time.now.strftime("%Y-%m-%d %H:%M:%S")
  #   end
  #   end
  #
  #   Dry::Logger.register_formatter(:my_formatter, MyFormatter)
  #
  #   logger = Dry.Logger(:app, formatter: :my_formatter, template: :details)
  #
  #   logger.info "Hello World"
  #   # [test] [INFO] [2022-11-15 10:06:29] WOAH: Hello World
  # @return [Hash]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/global.rb#34
  def register_formatter(name, formatter); end

  # Register a new template
  #
  # @api public
  # @example basic template
  #   Dry::Logger.register_template(:request, "[%<severity>s] %<verb>s %<path>s")
  #
  #   logger = Dry.Logger(:my_app, template: :request)
  #
  #   logger.info(verb: "GET", path: "/users")
  #   # [INFO] GET /users
  # @example template with colors
  #   Dry::Logger.register_template(
  #   :request, "[%<severity>s] <green>%<verb>s</green> <blue>%<path>s</blue>"
  #   )
  # @return [Hash]
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/global.rb#57
  def register_template(name, template); end

  # Internal templates registry
  #
  # @api private
  # @since 1.0.0
  #
  # source://dry-logger//lib/dry/logger/global.rb#118
  def templates; end
end

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#41
Dry::Logger::INFO = T.let(T.unsafe(nil), Integer)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#69
Dry::Logger::LEVELS = T.let(T.unsafe(nil), Hash)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#61
Dry::Logger::LEVEL_RANGE = T.let(T.unsafe(nil), Range)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#29
Dry::Logger::LOG_METHODS = T.let(T.unsafe(nil), Array)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#9
Dry::Logger::NEW_LINE = T.let(T.unsafe(nil), String)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#13
Dry::Logger::SEPARATOR = T.let(T.unsafe(nil), String)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#17
Dry::Logger::TAB = T.let(T.unsafe(nil), String)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#57
Dry::Logger::UNKNOWN = T.let(T.unsafe(nil), Integer)

# @api private
# @since 1.0.0
#
# source://dry-logger//lib/dry/logger/constants.rb#45
Dry::Logger::WARN = T.let(T.unsafe(nil), Integer)
