# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-inflector` gem.
# Please instead update this file by running `bin/tapioca gem dry-inflector`.

module Dry
  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject.rb#61
    def AutoInject(container, options = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli.rb#221
    def CLI(registry_or_command = T.unsafe(nil), &block); end

    # @api public
    #
    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.0.0/lib/dry/core.rb#41
    def Equalizer(*keys, **options); end
  end
end

module Dry::AutoInject
  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject.rb#8
    def loader; end
  end
end

class Dry::AutoInject::Builder
  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#15
  def initialize(container, options = T.unsafe(nil)); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#21
  def [](*dependency_names); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#7
  def container; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#10
  def strategies; end

  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#31
  def method_missing(name, *args, &block); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/builder.rb#25
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

class Dry::AutoInject::DependencyMap
  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#11
  def initialize(*dependencies); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#27
  def inspect; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#31
  def names; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#35
  def to_h; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#35
  def to_hash; end

  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#52
  def add_dependency(name, identifier); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/dependency_map.rb#42
  def name_for(identifier); end
end

class Dry::AutoInject::Injector < ::BasicObject
  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#20
  def initialize(container, strategy, builder:); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#26
  def [](*dependency_names); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#15
  def builder; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#9
  def container; end

  def respond_to?(*_arg0); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#12
  def strategy; end

  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#36
  def method_missing(name, *_args); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/injector.rb#30
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

class Dry::AutoInject::MethodParameters
  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#29
  def initialize(parameters); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#57
  def empty?; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#53
  def keyword?(name); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#47
  def keyword_names; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#61
  def length; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#27
  def parameters; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#65
  def pass_through?; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#39
  def sequential_arguments?; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#33
  def splat?; end

  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#11
    def of(obj, name); end
  end
end

# source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#69
Dry::AutoInject::MethodParameters::EMPTY = T.let(T.unsafe(nil), Dry::AutoInject::MethodParameters)

# source://dry-auto_inject/1.0.0/lib/dry/auto_inject/method_parameters.rb#9
Dry::AutoInject::MethodParameters::PASS_THROUGH = T.let(T.unsafe(nil), Array)

class Dry::AutoInject::Strategies
  extend ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  class << self
    # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies.rb#9
    def register_default(name, strategy); end
  end
end

class Dry::AutoInject::Strategies::Args < ::Dry::AutoInject::Strategies::Constructor
  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/args.rb#22
  def define_initialize(klass); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/args.rb#35
  def define_initialize_with_params; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/args.rb#48
  def define_initialize_with_splat(super_parameters); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/args.rb#10
  def define_new; end
end

class Dry::AutoInject::Strategies::Constructor < ::Module
  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#15
  def initialize(container, *dependency_names); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#13
  def class_mod; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#10
  def container; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#11
  def dependency_map; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#24
  def included(klass); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#12
  def instance_mod; end

  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#50
  def define_initialize(_klass); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#46
  def define_new; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/constructor.rb#38
  def define_readers; end
end

class Dry::AutoInject::Strategies::Constructor::ClassMethods < ::Module; end
class Dry::AutoInject::Strategies::Constructor::InstanceMethods < ::Module; end

class Dry::AutoInject::Strategies::Hash < ::Dry::AutoInject::Strategies::Constructor
  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/hash.rb#22
  def define_initialize(klass); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/hash.rb#10
  def define_new; end
end

class Dry::AutoInject::Strategies::Kwargs < ::Dry::AutoInject::Strategies::Constructor
  private

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#82
  def assign_dependencies(kwargs, destination); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#24
  def define_initialize(klass); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#40
  def define_initialize_with_keywords(super_parameters); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#59
  def define_initialize_with_splat(super_parameters); end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#10
  def define_new; end

  # source://dry-auto_inject/1.0.0/lib/dry/auto_inject/strategies/kwargs.rb#93
  def slice_kwargs(kwargs, super_parameters); end
end

class Dry::CLI
  # source://dry-cli/1.0.0/lib/dry/cli.rb#45
  def initialize(command_or_registry = T.unsafe(nil), &block); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#63
  def call(arguments: T.unsafe(nil), out: T.unsafe(nil), err: T.unsafe(nil)); end

  private

  # source://dry-cli/1.0.0/lib/dry/cli.rb#202
  def anonymous_registry(&block); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#146
  def build_command(command); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#190
  def command?(command); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#88
  def err; end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#159
  def error(result); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#152
  def help(command, prog_name); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#80
  def kommand; end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#84
  def out; end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#132
  def parse(command, arguments, names); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#97
  def perform_command(arguments); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#109
  def perform_registry(arguments); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#76
  def registry; end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#176
  def signal_exception(exception); end

  # source://dry-cli/1.0.0/lib/dry/cli.rb#166
  def usage(result); end

  class << self
    # source://dry-cli/1.0.0/lib/dry/cli.rb#28
    def command?(command); end
  end
end

class Dry::CLI::Argument < ::Dry::CLI::Option
  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#126
  def argument?; end
end

module Dry::CLI::Banner
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#85
    def arguments(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#128
    def build_subcommands_list(subcommands); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#19
    def call(command, name); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#71
    def command_arguments(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#57
    def command_description(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#49
    def command_examples(command, name); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#33
    def command_name(name); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#39
    def command_name_and_arguments(command, name); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#79
    def command_options(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#63
    def command_subcommands(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#98
    def extended_command_arguments(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/banner.rb#107
    def extended_command_options(command); end
  end
end

class Dry::CLI::Command
  extend ::Forwardable

  # source://forwardable/1.3.2/forwardable.rb#229
  def arguments(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_params(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def description(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def examples(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def optional_arguments(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def options(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def params(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def required_arguments(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def subcommands(*args, **_arg1, &block); end

  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#201
    def argument(name, options = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#329
    def default_params; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#71
    def desc(description); end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#107
    def example(*examples); end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#14
    def inherited(base); end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#315
    def option(name, options = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#343
    def optional_arguments; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#321
    def params; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#337
    def required_arguments; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#349
    def subcommands; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#363
    def superclass_arguments; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#369
    def superclass_options; end

    # source://dry-cli/1.0.0/lib/dry/cli/command.rb#355
    def superclass_variable_dup(var); end
  end
end

module Dry::CLI::Command::ClassMethods
  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#40
  def arguments; end

  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#32
  def description; end

  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#36
  def examples; end

  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#44
  def options; end

  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#48
  def subcommands; end

  # source://dry-cli/1.0.0/lib/dry/cli/command.rb#52
  def subcommands=(_arg0); end
end

class Dry::CLI::CommandRegistry
  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#14
  def initialize; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#41
  def get(arguments); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#21
  def set(name, command, aliases); end
end

class Dry::CLI::CommandRegistry::Chain
  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#233
  def initialize; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#239
  def append(&callback); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#229
  def chain; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#245
  def run(context, *args); end
end

class Dry::CLI::CommandRegistry::LookupResult
  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#184
  def initialize(node, arguments, names, found); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#217
  def after_callbacks; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#180
  def arguments; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#211
  def before_callbacks; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#199
  def children; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#205
  def command; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#193
  def found?; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#176
  def names; end
end

class Dry::CLI::CommandRegistry::Node
  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#107
  def initialize(parent = T.unsafe(nil)); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#103
  def after_callbacks; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#144
  def alias!(key, child); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#91
  def aliases; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#150
  def aliases!(aliases); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#99
  def before_callbacks; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#87
  def children; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#164
  def children?; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#95
  def command; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#131
  def leaf!(command); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#158
  def leaf?; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#125
  def lookup(token); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#83
  def parent; end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#119
  def put(parent, key); end

  # source://dry-cli/1.0.0/lib/dry/cli/command_registry.rb#137
  def subcommands!(command); end
end

class Dry::CLI::Error < ::StandardError; end

module Dry::CLI::Inflector
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/inflector.rb#10
    def dasherize(input); end
  end
end

class Dry::CLI::InvalidCallbackError < ::Dry::CLI::Error
  # source://dry-cli/1.0.0/lib/dry/cli/errors.rb#25
  def initialize(callback); end
end

class Dry::CLI::Option
  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#20
  def initialize(name, options = T.unsafe(nil)); end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#109
  def alias_names; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#27
  def aliases; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#82
  def argument?; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#64
  def array?; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#58
  def boolean?; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#70
  def default; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#33
  def desc; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#76
  def description_name; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#12
  def name; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#16
  def options; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#89
  def parser_options; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#40
  def required?; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#46
  def type; end

  # source://dry-cli/1.0.0/lib/dry/cli/option.rb#52
  def values; end
end

module Dry::CLI::Parser
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#16
    def call(command, arguments, prog_name); end

    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#72
    def match_arguments(command_arguments, arguments); end

    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#42
    def parse_required_params(command, arguments, prog_name, parsed_options); end
  end
end

class Dry::CLI::Parser::Result
  # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#118
  def initialize(arguments: T.unsafe(nil), error: T.unsafe(nil), help: T.unsafe(nil)); end

  # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#110
  def arguments; end

  # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#114
  def error; end

  # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#126
  def error?; end

  # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#132
  def help?; end

  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#104
    def failure(error = T.unsafe(nil)); end

    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#92
    def help; end

    # source://dry-cli/1.0.0/lib/dry/cli/parser.rb#98
    def success(arguments = T.unsafe(nil)); end
  end
end

module Dry::CLI::ProgramName
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/program_name.rb#16
    def call(names = T.unsafe(nil), program_name: T.unsafe(nil)); end
  end
end

# source://dry-cli/1.0.0/lib/dry/cli/program_name.rb#12
Dry::CLI::ProgramName::SEPARATOR = T.let(T.unsafe(nil), String)

module Dry::CLI::Registry
  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#261
  def after(command_name, callback = T.unsafe(nil), &blk); end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#173
  def before(command_name, callback = T.unsafe(nil), &blk); end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#269
  def get(arguments); end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#78
  def register(name, command = T.unsafe(nil), aliases: T.unsafe(nil), &block); end

  private

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#288
  def _callback(callback, blk); end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#279
  def command(command_name); end

  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#13
    def extended(base); end
  end
end

# source://dry-cli/1.0.0/lib/dry/cli/registry.rb#275
Dry::CLI::Registry::COMMAND_NAME_SEPARATOR = T.let(T.unsafe(nil), String)

class Dry::CLI::Registry::Prefix
  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#311
  def initialize(registry, prefix, aliases); end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#321
  def register(name, command, aliases: T.unsafe(nil)); end

  private

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#334
  def prefix; end

  # source://dry-cli/1.0.0/lib/dry/cli/registry.rb#330
  def registry; end
end

class Dry::CLI::UnknownCommandError < ::Dry::CLI::Error
  # source://dry-cli/1.0.0/lib/dry/cli/errors.rb#16
  def initialize(command_name); end
end

module Dry::CLI::Usage
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#52
    def arguments(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#19
    def call(result); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#89
    def command_name(result, name); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#83
    def commands(result); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#31
    def commands_and_arguments(result); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#67
    def description(command); end

    # source://dry-cli/1.0.0/lib/dry/cli/usage.rb#75
    def justify(string, padding, usage); end
  end
end

# source://dry-cli/1.0.0/lib/dry/cli/usage.rb#15
Dry::CLI::Usage::ROOT_COMMAND_WITH_SUBCOMMANDS_BANNER = T.let(T.unsafe(nil), String)

# source://dry-cli/1.0.0/lib/dry/cli/usage.rb#14
Dry::CLI::Usage::SUBCOMMAND_BANNER = T.let(T.unsafe(nil), String)

# source://dry-cli/1.0.0/lib/dry/cli/version.rb#6
Dry::CLI::VERSION = T.let(T.unsafe(nil), String)

# A simple configuration mixin
#
# @api public
# @example class-level configuration
#
#   class App
#   extend Dry::Configurable
#
#   setting :database do
#   setting :dsn, 'sqlite:memory'
#   end
#   end
#
#   App.config.database.dsn = 'jdbc:sqlite:memory'
#   App.config.database.dsn
#   # => "jdbc:sqlite:memory"
# @example instance-level configuration
#
#   class App
#   include Dry::Configurable
#
#   setting :database
#   end
#
#   production = App.new
#   production.config.database = ENV['DATABASE_URL']
#   production.finalize!
#
#   development = App.new
#   development.config.database = 'jdbc:sqlite:memory'
#   development.finalize!
module Dry::Configurable
  include ::Dry::Core::Constants
  include ::Dry::Configurable::InstanceMethods

  mixes_in_class_methods ::Dry::Configurable::ClassMethods

  # Mixes in test interface into the configurable module
  #
  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/test_interface.rb#20
  def enable_test_interface; end

  class << self
    # @api private
    # @private
    #
    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#64
    def extended(klass); end

    # @api private
    # @private
    #
    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#70
    def included(klass); end

    # @api public
    #
    # source://dry-configurable/1.0.1/lib/dry/configurable.rb#49
    def loader; end
  end
end

# @api public
class Dry::Configurable::AlreadyIncludedError < ::Dry::Configurable::Error; end

module Dry::Configurable::ClassMethods
  include ::Dry::Configurable::Methods

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#72
  def __config_build__(settings = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#82
  def __config_dsl__; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#77
  def __config_extension__; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#90
  def __config_reader__; end

  # Return configuration
  #
  # @api public
  # @return [Config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#67
  def config; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#11
  def inherited(subclass); end

  # Add a setting to the configuration
  #
  # @api public
  # @param name [Mixed] The accessor key for the configuration value
  # @param default [Mixed] Default value for the setting
  # @param constructor [#call] Transformation given value will go through
  # @param reader [Boolean] Whether a reader accessor must be created
  # @return [Dry::Configurable::Config]
  # @yield A block can be given to add nested settings.
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#43
  def setting(*args, **options, &block); end

  # Returns the defined settings for the class.
  #
  # @api public
  # @return [Settings]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/class_methods.rb#58
  def settings; end
end

# Setting compiler used internally by the DSL
#
# @api private
class Dry::Configurable::Compiler
  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/compiler.rb#9
  def call(ast); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/compiler.rb#18
  def visit(node); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/compiler.rb#30
  def visit_nested(node); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/compiler.rb#24
  def visit_setting(node); end
end

# Config exposes setting values through a convenient API
#
# @api public
class Dry::Configurable::Config
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Config] a new instance of Config
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#24
  def initialize(settings, values: T.unsafe(nil)); end

  # Get config value by a key
  #
  # @api public
  # @param name [String, Symbol]
  # @return Config value
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#47
  def [](name); end

  # Set config value.
  # Note that finalized configs cannot be changed.
  #
  # @api public
  # @param name [String, Symbol]
  # @param value [Object]
  # @raise [FrozenConfigError]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#69
  def []=(name, value); end

  # @api private
  #
  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#87
  def _dry_equalizer_hash; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#14
  def _settings; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#17
  def _values; end

  # Returns true if the value for the given key has been set on this config.
  #
  # For simple values, this returns true if the value has been explicitly assigned.
  #
  # For cloneable (mutable) values, since these are captured on read, returns true if the value
  # does not compare equally to its corresdponing default value. This relies on these objects
  # having functioning `#==` checks.
  #
  # @api public
  # @return [Bool]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#116
  def configured?(key); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#38
  def dup_for_settings(settings); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#159
  def finalize!(freeze_values: T.unsafe(nil)); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#152
  def hash; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#181
  def pristine; end

  # Returns config values as a hash, with nested values also converted from {Config} instances
  # into hashes.
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#144
  def to_h; end

  # Update config with new values
  #
  # @api public
  # @param values [Hash, #to_hash] A hash with new values
  # @return [Config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#90
  def update(values); end

  # Returns the current config values.
  #
  # Nested configs remain in their {Config} instances.
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#131
  def values; end

  protected

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#20
  def _configured; end

  private

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#208
  def dup_values; end

  # @api private
  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#31
  def initialize_copy(source); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#187
  def method_missing(name, *args); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#200
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/config.rb#204
  def setting_name_from_method(method_name); end
end

# Setting DSL used by the class API
#
# @api private
class Dry::Configurable::DSL
  # @api private
  # @return [DSL] a new instance of DSL
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#17
  def initialize(**options, &block); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#13
  def ast; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#11
  def compiler; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#49
  def config_class; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#53
  def default; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#15
  def options; end

  # Registers a new setting node and compile it into a setting object
  #
  # @api private
  # @return Setting
  # @see ClassMethods.setting
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#29
  def setting(name, **options, &block); end

  private

  # @api private
  # @raise [ArgumentError]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#59
  def ensure_valid_options(options); end

  # Returns a tuple of valid and invalid options hashes derived from the options hash
  # given to the setting
  #
  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#69
  def valid_and_invalid_options(options); end
end

# @api private
#
# source://dry-configurable/1.0.1/lib/dry/configurable/dsl.rb#9
Dry::Configurable::DSL::VALID_NAME = T.let(T.unsafe(nil), Regexp)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::EMPTY_STRING = T.let(T.unsafe(nil), String)

# @api public
class Dry::Configurable::Error < ::StandardError; end

# @api public
class Dry::Configurable::Extension < ::Module
  # @api private
  # @return [Extension] a new instance of Extension
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/extension.rb#13
  def initialize(config_class: T.unsafe(nil), default_undefined: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/extension.rb#7
  def config_class; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/extension.rb#10
  def default_undefined; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/extension.rb#21
  def extended(klass); end

  # @api private
  # @raise [AlreadyIncludedError]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/extension.rb#28
  def included(klass); end
end

# @api public
class Dry::Configurable::FrozenConfigError < ::Dry::Configurable::Error; end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::IDENTITY = T.let(T.unsafe(nil), Proc)

# Initializer method which is prepended when `Dry::Configurable`
# is included in a class
#
# @api private
module Dry::Configurable::Initializer
  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/instance_methods.rb#14
  def initialize(*_arg0, **_arg1); end
end

# Instance-level API when `Dry::Configurable` is included in a class
#
# @api public
module Dry::Configurable::InstanceMethods
  include ::Dry::Configurable::Methods

  # Return object's configuration
  #
  # @api public
  # @return [Config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/instance_methods.rb#33
  def config; end

  # Finalize the config and freeze the object
  #
  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/instance_methods.rb#40
  def finalize!(freeze_values: T.unsafe(nil)); end

  private

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/instance_methods.rb#48
  def initialize_copy(source); end
end

# Common API for both classes and instances
#
# @api public
module Dry::Configurable::Methods
  # @api public
  # @raise [FrozenConfigError]
  # @yield [config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/methods.rb#10
  def configure(&block); end

  # Finalize and freeze configuration
  #
  # @api public
  # @return [Dry::Configurable::Config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/methods.rb#22
  def finalize!(freeze_values: T.unsafe(nil)); end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::Self = T.let(T.unsafe(nil), Proc)

# A defined setting.
#
# @api public
class Dry::Configurable::Setting
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Setting] a new instance of Setting
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#43
  def initialize(name, default:, constructor: T.unsafe(nil), children: T.unsafe(nil), **options); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#32
  def children; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#67
  def cloneable?; end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#29
  def constructor; end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#23
  def default; end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#26
  def mutable; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#67
  def mutable?; end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#20
  def name; end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#35
  def options; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#62
  def reader?; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#73
  def to_value; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#38
    def mutable_value?(value); end
  end
end

# @api public
#
# source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#15
Dry::Configurable::Setting::DEFAULT_CONSTRUCTOR = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#17
Dry::Configurable::Setting::MUTABLE_VALUE_TYPES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-configurable/1.0.1/lib/dry/configurable/setting.rb#13
Dry::Configurable::Setting::OPTIONS = T.let(T.unsafe(nil), Array)

# A collection of defined settings on a given class.
#
# @api private
class Dry::Configurable::Settings
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable

  # @api private
  # @return [Settings] a new instance of Settings
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#17
  def initialize(settings = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#27
  def <<(setting); end

  # Returns the setting for the given name, if found.
  #
  # @api public
  # @return [Setting, nil] the setting, or nil if not found
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#37
  def [](name); end

  # @api public
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#60
  def each(&block); end

  # Returns true if a setting for the given name is defined.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#46
  def key?(name); end

  # Returns the list of defined setting names.
  #
  # @api public
  # @return [Array<Symbol>]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#55
  def keys; end

  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#14
  def settings; end

  private

  # @api private
  # @api private
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/settings.rb#22
  def initialize_copy(source); end
end

# Methods meant to be used in a testing scenario
#
# @api public
module Dry::Configurable::TestInterface
  # Resets configuration to default values
  #
  # @api public
  # @return [Dry::Configurable::Config]
  #
  # source://dry-configurable/1.0.1/lib/dry/configurable/test_interface.rb#12
  def reset_config; end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Configurable::Undefined = T.let(T.unsafe(nil), Object)

module Dry::Core
  include ::Dry::Core::Constants

  class << self
    # source://dry-core/1.0.0/lib/dry/core.rb#15
    def loader; end
  end
end

class Dry::Core::BasicObject < ::BasicObject
  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#32
  def class; end

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#44
  def inspect; end

  def instance_of?(_arg0); end
  def is_a?(_arg0); end
  def kind_of?(_arg0); end

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#101
  def object_id; end

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#113
  def pretty_print(printer); end

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#124
  def respond_to?(method_name, include_all = T.unsafe(nil)); end

  private

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#140
  def __inspect; end

  # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#134
  def respond_to_missing?(_method_name, _include_all); end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/basic_object.rb#23
    def const_missing(name); end
  end
end

module Dry::Core::Cache
  # source://dry-core/1.0.0/lib/dry/core/cache.rb#36
  def cache; end

  # source://dry-core/1.0.0/lib/dry/core/cache.rb#51
  def fetch_or_store(*args, &block); end

  # source://dry-core/1.0.0/lib/dry/core/cache.rb#30
  def inherited(klass); end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/cache.rb#23
    def extended(klass); end
  end
end

module Dry::Core::Cache::Methods
  # source://dry-core/1.0.0/lib/dry/core/cache.rb#63
  def fetch_or_store(*_arg0, **_arg1, &_arg2); end
end

module Dry::Core::ClassAttributes
  include ::Dry::Core::Constants

  # source://dry-core/1.0.0/lib/dry/core/class_attributes.rb#68
  def defines(*args, type: T.unsafe(nil), coerce: T.unsafe(nil)); end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::ClassAttributes::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Core::ClassBuilder
  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#11
  def initialize(name:, parent: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#35
  def call; end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#9
  def name; end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#9
  def namespace; end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#9
  def parent; end

  private

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#50
  def create_anonymous; end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#81
  def create_base(namespace, name, parent); end

  # source://dry-core/1.0.0/lib/dry/core/class_builder.rb#64
  def create_named; end
end

class Dry::Core::ClassBuilder::ParentClassMismatch < ::TypeError; end

module Dry::Core::Constants
  class << self
    # source://dry-core/1.0.0/lib/dry/core/constants.rb#108
    def included(base); end
  end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#20
Dry::Core::Constants::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#22
Dry::Core::Constants::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#24
Dry::Core::Constants::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#26
Dry::Core::Constants::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#28
Dry::Core::Constants::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#30
Dry::Core::Constants::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#45
Dry::Core::Constants::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#43
Dry::Core::Constants::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Core::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#83
  def config; end
end

class Dry::Core::Container::Config
  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#22
  def initialize(namespace_separator: T.unsafe(nil), resolver: T.unsafe(nil), registry: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#13
  def namespace_separator; end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#13
  def namespace_separator=(_arg0); end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#19
  def registry; end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#19
  def registry=(_arg0); end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#16
  def resolver; end

  # source://dry-core/1.0.0/lib/dry/core/container/config.rb#16
  def resolver=(_arg0); end
end

# source://dry-core/1.0.0/lib/dry/core/container/config.rb#8
Dry::Core::Container::Config::DEFAULT_NAMESPACE_SEPARATOR = T.let(T.unsafe(nil), String)

# source://dry-core/1.0.0/lib/dry/core/container/config.rb#10
Dry::Core::Container::Config::DEFAULT_REGISTRY = T.let(T.unsafe(nil), Dry::Core::Container::Registry)

# source://dry-core/1.0.0/lib/dry/core/container/config.rb#9
Dry::Core::Container::Config::DEFAULT_RESOLVER = T.let(T.unsafe(nil), Dry::Core::Container::Resolver)

module Dry::Core::Container::Configuration
  # source://dry-core/1.0.0/lib/dry/core/container/configuration.rb#31
  def configure; end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/container/configuration.rb#13
    def extended(klass); end
  end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::EMPTY_STRING = T.let(T.unsafe(nil), String)

class Dry::Core::Container::Error < ::StandardError; end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::IDENTITY = T.let(T.unsafe(nil), Proc)

class Dry::Core::Container::Item
  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#18
  def initialize(item, options = T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#26
  def call; end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#36
  def callable?; end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#12
  def item; end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#43
  def map(func); end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#15
  def options; end

  # source://dry-core/1.0.0/lib/dry/core/container/item.rb#31
  def value?; end
end

class Dry::Core::Container::Item::Callable < ::Dry::Core::Container::Item
  # source://dry-core/1.0.0/lib/dry/core/container/item/callable.rb#15
  def call; end
end

class Dry::Core::Container::Item::Factory
  # source://dry-core/1.0.0/lib/dry/core/container/item/factory.rb#18
  def call(item, options = T.unsafe(nil)); end
end

class Dry::Core::Container::Item::Memoizable < ::Dry::Core::Container::Item
  # source://dry-core/1.0.0/lib/dry/core/container/item/memoizable.rb#23
  def initialize(item, options = T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/container/item/memoizable.rb#33
  def call; end

  # source://dry-core/1.0.0/lib/dry/core/container/item/memoizable.rb#13
  def memoize_mutex; end

  private

  # source://dry-core/1.0.0/lib/dry/core/container/item/memoizable.rb#42
  def raise_not_supported_error; end
end

class Dry::Core::Container::KeyError < ::KeyError; end

module Dry::Core::Container::Mixin
  mixes_in_class_methods ::Dry::Core::Container::Configuration
  mixes_in_class_methods ::Dry::Configurable
  mixes_in_class_methods ::Dry::Configurable::ClassMethods

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#144
  def [](key); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#288
  def _container; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#300
  def clone; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#227
  def decorate(key, with: T.unsafe(nil), &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#293
  def dup; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#218
  def each(&block); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#201
  def each_key(&block); end

  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#51
  def enable_stubs!; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#281
  def freeze; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#272
  def import(namespace); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#181
  def key?(key); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#190
  def keys; end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#158
  def merge(other, namespace: T.unsafe(nil), &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#253
  def namespace(namespace, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#104
  def register(key, contents = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#131
  def resolve(key, &block); end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#53
    def extended(base); end

    # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#78
    def included(base); end
  end
end

module Dry::Core::Container::Mixin::Initializer
  # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#71
  def initialize(*args, &block); end
end

# source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#48
Dry::Core::Container::Mixin::PREFIX_NAMESPACE = T.let(T.unsafe(nil), Proc)

class Dry::Core::Container::Namespace
  # source://dry-core/1.0.0/lib/dry/core/container/namespace.rb#40
  def initialize(name, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace.rb#28
  def block; end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace.rb#25
  def name; end
end

class Dry::Core::Container::NamespaceDSL < ::SimpleDelegator
  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#24
  def initialize(container, namespace, namespace_separator, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#45
  def import(namespace); end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#41
  def namespace(namespace, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#37
  def register(key, *args, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#51
  def resolve(key); end

  private

  # source://dry-core/1.0.0/lib/dry/core/container/namespace_dsl.rb#57
  def namespaced(key); end
end

class Dry::Core::Container::Registry
  # source://dry-core/1.0.0/lib/dry/core/container/registry.rb#11
  def initialize; end

  # source://dry-core/1.0.0/lib/dry/core/container/registry.rb#33
  def call(container, key, item, options); end

  # source://dry-core/1.0.0/lib/dry/core/container/registry.rb#46
  def factory; end
end

class Dry::Core::Container::Resolver
  # source://dry-core/1.0.0/lib/dry/core/container/resolver.rb#27
  def call(container, key); end

  # source://dry-core/1.0.0/lib/dry/core/container/resolver.rb#84
  def each(container, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/resolver.rb#69
  def each_key(container, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/resolver.rb#49
  def key?(container, key); end

  # source://dry-core/1.0.0/lib/dry/core/container/resolver.rb#58
  def keys(container); end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::Self = T.let(T.unsafe(nil), Proc)

module Dry::Core::Container::Stub
  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#37
  def enable_stubs!; end

  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#10
  def resolve(key); end

  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#15
  def stub(key, value, &block); end

  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#31
  def unstub(*keys); end

  private

  # source://dry-core/1.0.0/lib/dry/core/container/stub.rb#44
  def _stubs; end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Container::Undefined = T.let(T.unsafe(nil), Object)

module Dry::Core::Deprecations
  class << self
    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#115
    def [](tag); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#51
    def announce(name, msg, tag: T.unsafe(nil), uplevel: T.unsafe(nil)); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#68
    def deprecated_name_message(old, new = T.unsafe(nil), msg = T.unsafe(nil)); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#60
    def deprecation_message(name, msg); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#85
    def logger(output = T.unsafe(nil)); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#105
    def set_logger!(output = T.unsafe(nil)); end

    # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#39
    def warn(msg, tag: T.unsafe(nil), uplevel: T.unsafe(nil)); end
  end
end

module Dry::Core::Deprecations::Interface
  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#157
  def deprecate(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#190
  def deprecate_class_method(old_name, new_name = T.unsafe(nil), message: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#212
  def deprecate_constant(constant_name, message: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#137
  def deprecation_tag(tag = T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#148
  def warn(msg); end
end

# source://dry-core/1.0.0/lib/dry/core/deprecations.rb#30
Dry::Core::Deprecations::STACK = T.let(T.unsafe(nil), Proc)

class Dry::Core::Deprecations::Tagged < ::Module
  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#122
  def initialize(tag); end

  # source://dry-core/1.0.0/lib/dry/core/deprecations.rb#127
  def extended(base); end
end

module Dry::Core::DescendantsTracker
  # source://dry-core/1.0.0/lib/dry/core/descendants_tracker.rb#54
  def descendants; end

  protected

  # source://dry-core/1.0.0/lib/dry/core/descendants_tracker.rb#59
  def add_descendant(descendant); end

  private

  # source://dry-core/1.0.0/lib/dry/core/descendants_tracker.rb#70
  def inherited(descendant); end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/descendants_tracker.rb#32
    def setup(target); end

    private

    # source://dry-core/1.0.0/lib/dry/core/descendants_tracker.rb#39
    def extended(base); end
  end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::EMPTY_STRING = T.let(T.unsafe(nil), String)

class Dry::Core::Equalizer < ::Module
  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#20
  def initialize(*keys, **options); end

  private

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#61
  def define_cmp_method; end

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#76
  def define_hash_method(immutable:); end

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#98
  def define_inspect_method; end

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#50
  def define_methods(inspect: T.unsafe(nil), immutable: T.unsafe(nil)); end

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#37
  def included(descendant); end
end

module Dry::Core::Equalizer::Methods
  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#135
  def ==(other); end

  # source://dry-core/1.0.0/lib/dry/core/equalizer.rb#120
  def eql?(other); end
end

module Dry::Core::Extensions
  # source://dry-core/1.0.0/lib/dry/core/extensions.rb#43
  def available_extension?(name); end

  # source://dry-core/1.0.0/lib/dry/core/extensions.rb#50
  def load_extensions(*extensions); end

  # source://dry-core/1.0.0/lib/dry/core/extensions.rb#35
  def register_extension(name, &block); end

  class << self
    # source://dry-core/1.0.0/lib/dry/core/extensions.rb#25
    def extended(obj); end
  end
end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::IDENTITY = T.let(T.unsafe(nil), Proc)

module Dry::Core::Inflector
  class << self
    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#70
    def camelize(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#136
    def classify(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#125
    def constantize(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#114
    def demodulize(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#37
    def detect_backend; end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#59
    def inflector; end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#103
    def pluralize(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#26
    def realize_backend(path, backend_factory); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#48
    def select_backend(name = T.unsafe(nil)); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#92
    def singularize(input); end

    # source://dry-core/1.0.0/lib/dry/core/inflector.rb#81
    def underscore(input); end
  end
end

# source://dry-core/1.0.0/lib/dry/core/inflector.rb#8
Dry::Core::Inflector::BACKENDS = T.let(T.unsafe(nil), Hash)

class Dry::Core::InvalidClassAttributeValueError < ::StandardError
  # source://dry-core/1.0.0/lib/dry/core/errors.rb#6
  def initialize(name, value); end
end

module Dry::Core::Memoizable
  mixes_in_class_methods ::Dry::Core::Memoizable::ClassInterface::Object

  class << self
    # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#48
    def included(klass); end
  end
end

module Dry::Core::Memoizable::ClassInterface; end

module Dry::Core::Memoizable::ClassInterface::Base
  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#15
  def inherited(base); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#11
  def memoize(*names); end
end

module Dry::Core::Memoizable::ClassInterface::BasicObject
  include ::Dry::Core::Memoizable::ClassInterface::Base

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#26
  def new(*_arg0); end
end

module Dry::Core::Memoizable::ClassInterface::Object
  include ::Dry::Core::Memoizable::ClassInterface::Base

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#36
  def new(*_arg0, **_arg1); end
end

# source://dry-core/1.0.0/lib/dry/core/memoizable.rb#6
Dry::Core::Memoizable::MEMOIZED_HASH = T.let(T.unsafe(nil), Hash)

class Dry::Core::Memoizable::Memoizer < ::Module
  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#67
  def initialize(klass, names); end

  private

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#160
  def declaration(definition, lookup); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#81
  def define_memoizable(method:); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#192
  def make_bind_name(idx); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#197
  def map_bind_type(type, name, original_params, defined_types); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#183
  def name_from_param(name); end

  # source://dry-core/1.0.0/lib/dry/core/memoizable.rb#229
  def param(name, type); end
end

# source://dry-core/1.0.0/lib/dry/core/memoizable.rb#60
Dry::Core::Memoizable::Memoizer::KERNEL = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/memoizable.rb#7
Dry::Core::Memoizable::PARAM_PLACEHOLDERS = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::Core::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-core/1.0.0/lib/dry/core/version.rb#5
Dry::Core::VERSION = T.let(T.unsafe(nil), String)

# dry-inflector
#
# @since 0.1.0
class Dry::Inflector
  # Instantiate the inflector
  #
  # @example Basic usage
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  # @example Custom inflection rules
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.plural      "virus",   "viruses" # specify a rule for #pluralize
  #   inflections.singular    "thieves", "thief"   # specify a rule for #singularize
  #   inflections.uncountable "dry-inflector"      # add an exception for an uncountable word
  #   end
  # @param blk [Proc] an optional block to specify custom inflection rules
  # @return [Dry::Inflector] the inflector
  # @since 0.1.0
  # @yieldparam the [Dry::Inflector::Inflections] inflection rules
  #
  # source://dry-inflector//lib/dry/inflector.rb#33
  def initialize(&blk); end

  # Upper camelize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.camelize_upper("data_mapper") # => "DataMapper"
  #   inflector.camelize_upper("dry/inflector") # => "Dry::Inflector"
  # @param input [String, Symbol] the input
  # @return [String] the upper camelized string
  # @since 0.1.3
  #
  # source://dry-inflector//lib/dry/inflector.rb#66
  def camelize(input); end

  # Lower camelize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.camelize_lower("data_mapper") # => "dataMapper"
  # @param input [String, Symbol] the input
  # @return [String] the lower camelized string
  # @since 0.1.3
  #
  # source://dry-inflector//lib/dry/inflector.rb#49
  def camelize_lower(input); end

  # Upper camelize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.camelize_upper("data_mapper") # => "DataMapper"
  #   inflector.camelize_upper("dry/inflector") # => "Dry::Inflector"
  # @param input [String, Symbol] the input
  # @return [String] the upper camelized string
  # @since 0.1.3
  #
  # source://dry-inflector//lib/dry/inflector.rb#66
  def camelize_upper(input); end

  # Classify a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.classify("books") # => "Book"
  # @param input [String, Symbol] the input
  # @return [String] the classified string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#104
  def classify(input); end

  # Find a constant with the name specified in the argument string
  #
  # The name is assumed to be the one of a top-level constant,
  # constant scope of caller is ignored
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.constantize("Module")         # => Module
  #   inflector.constantize("Dry::Inflector") # => Dry::Inflector
  # @param input [String, Symbol] the input
  # @return [Class, Module] the class or module
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#88
  def constantize(input); end

  # Dasherize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.dasherize("dry_inflector") # => "dry-inflector"
  # @param input [String, Symbol] the input
  # @return [String] the dasherized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#120
  def dasherize(input); end

  # Demodulize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.demodulize("Dry::Inflector") # => "Inflector"
  # @param input [String, Symbol] the input
  # @return [String] the demodulized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#136
  def demodulize(input); end

  # Creates a foreign key name
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.foreign_key("Message") => "message_id"
  # @param input [String, Symbol] the input
  # @return [String] foreign key
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#175
  def foreign_key(input); end

  # Humanize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.humanize("dry_inflector") # => "Dry inflector"
  #   inflector.humanize("author_id")     # => "Author"
  # @param input [String, Symbol] the input
  # @return [String] the humanized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#153
  def humanize(input); end

  # @api public
  # @return [String]
  # @since 0.2.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#308
  def inspect; end

  # Ordinalize a number
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.ordinalize(1)  # => "1st"
  #   inflector.ordinalize(2)  # => "2nd"
  #   inflector.ordinalize(3)  # => "3rd"
  #   inflector.ordinalize(10) # => "10th"
  #   inflector.ordinalize(23) # => "23rd"
  # @param number [Integer] the input
  # @return [String] the ordinalized number
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#195
  def ordinalize(number); end

  # Pluralize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.pluralize("book")  # => "books"
  #   inflector.pluralize("money") # => "money"
  # @param input [String, Symbol] the input
  # @return [String] the pluralized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#223
  def pluralize(input); end

  # Singularize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.singularize("books") # => "book"
  #   inflector.singularize("money") # => "money"
  # @param input [String] the input
  # @return [String] the singularized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#243
  def singularize(input); end

  # Tableize a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.tableize("Book") # => "books"
  # @param input [String, Symbol] the input
  # @return [String] the tableized string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#262
  def tableize(input); end

  # @api public
  # @return [String]
  # @since 0.2.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#308
  def to_s; end

  # Check if the input is an uncountable word
  #
  # @api private
  # @param input [String] the input
  # @return [TrueClass, FalseClass] the result of the check
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#300
  def uncountable?(input); end

  # Underscore a string
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new
  #   inflector.underscore("dry-inflector") # => "dry_inflector"
  # @param input [String, Symbol] the input
  # @return [String] the underscored string
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#279
  def underscore(input); end

  private

  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector.rb#323
  def inflections; end

  # @api private
  # @since 0.1.3
  #
  # source://dry-inflector//lib/dry/inflector.rb#327
  def internal_camelize(input, upper); end
end

# A set of acronyms
#
# @api private
# @since 0.1.2
class Dry::Inflector::Acronyms
  # @api private
  # @return [Acronyms] a new instance of Acronyms
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/acronyms.rb#14
  def initialize; end

  # @api private
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/acronyms.rb#27
  def add(rule, replacement); end

  # @api private
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/acronyms.rb#21
  def apply_to(word, capitalize: T.unsafe(nil)); end

  # @api private
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/acronyms.rb#10
  def regex; end

  private

  # @api private
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/acronyms.rb#36
  def define_regex_patterns; end
end

# @api private
# @since 0.1.2
#
# source://dry-inflector//lib/dry/inflector.rb#321
Dry::Inflector::DEFAULT_SEPARATOR = T.let(T.unsafe(nil), String)

# Inflections
#
# @since 0.1.0
class Dry::Inflector::Inflections
  # Instantiate the rules
  #
  # @api private
  # @return [Dry::Inflector::Inflections]
  # @since 0.1.0
  # @yieldparam [self]
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#76
  def initialize; end

  # Add one or more acronyms
  #
  # Acronyms affect how basic operations are performed, such
  # as camelize/underscore.
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.acronym "HTML"
  #   end
  #
  #   inflector.camelize("html")        # => "HTML"
  #   inflector.underscore("HTMLIsFun") # => "html_is_fun"
  # @param words [Array<String>] a list of acronyms
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#197
  def acronym(*words); end

  # Acronyms
  #
  # @api private
  # @return [Dry::Inflector::Acronyms]
  # @since 0.1.2
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#67
  def acronyms; end

  # Add a custom humanize rule
  #
  # Specifies a humanized form of a string by a regular expression rule or
  # by a string mapping.
  #
  # When using a regular expression based replacement, the normal humanize
  # formatting is called after the replacement.
  #
  # When a string is used, the human form should be specified as desired
  # (example: `"The name"`, not `"the_name"`)
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.human(/_cnt$/i, '\1_count')
  #   inflections.human("legacy_col_person_name", "Name")
  #   end
  # @param rule [String, Regexp] the rule
  # @param replacement [String] the replacement
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#224
  def human(rule, replacement); end

  # Human rules
  #
  # @api private
  # @return [Dry::Inflector::Rules]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#59
  def humans; end

  # Add a custom pluralization rule
  #
  # Specifies a new irregular that applies to both pluralization
  # and singularization at the same time.
  #
  # This can only be used for strings, not regular expressions.
  # You simply pass the irregular in singular and plural form.
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.singular "octopus", "octopi"
  #   end
  # @param singular [String] the singular
  # @param plural [String] the plural
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#151
  def irregular(singular, plural); end

  # Add a custom pluralization rule
  #
  # Specifies a new pluralization rule and its replacement.
  # The rule can either be a string or a regular expression.
  #
  # The replacement should always be a string that may include
  # references to the matched data from the rule.
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.plural "virus", "viruses"
  #   end
  # @param rule [String, Regexp] the rule
  # @param replacement [String] the replacement
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#105
  def plural(rule, replacement); end

  # Pluralization rules
  #
  # @api private
  # @return [Dry::Inflector::Rules]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#35
  def plurals; end

  # Add a custom singularization rule
  #
  # Specifies a new singularization rule and its replacement.
  # The rule can either be a string or a regular expression.
  #
  # The replacement should always be a string that may include
  # references to the matched data from the rule.
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.singular "thieves", "thief"
  #   end
  # @param rule [String, Regexp] the rule
  # @param replacement [String] the replacement
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#128
  def singular(rule, replacement); end

  # Singularization rules
  #
  # @api private
  # @return [Dry::Inflector::Rules]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#43
  def singulars; end

  # Add a custom rule for uncountable words
  #
  # Uncountable will not be inflected
  #
  # @example
  #   require "dry/inflector"
  #
  #   inflector = Dry::Inflector.new do |inflections|
  #   inflections.uncountable "money"
  #   inflections.uncountable "money", "information"
  #   inflections.uncountable %w(money information rice)
  #   end
  # @param words [Enumerable<String>]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#175
  def uncountable(*words); end

  # Uncountable rules
  #
  # @api private
  # @return [Set]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#51
  def uncountables; end

  private

  # Add irregular inflection
  #
  # @api private
  # @param rule [String] the rule
  # @param replacement [String] the replacement
  # @return [undefined]
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#239
  def add_irregular(rule, replacement, target); end

  # Add a new rule
  #
  # @api private
  # @param rule [String, Regexp] the rule
  # @param replacement [String, Regexp] the replacement
  # @param target [Dry::Inflector::Rules] the target
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/inflections.rb#252
  def rule(rule, replacement, target); end

  class << self
    # Instantiate a set of inflection rules.
    # It adds the default rules and the optional customizations, passed as a block.
    #
    # @api private
    # @param blk [Proc] the optional, custom rules
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections.rb#22
    def build(&blk); end
  end
end

# Default inflections
#
#
# @api private
# @since 0.1.0
module Dry::Inflector::Inflections::Defaults
  class << self
    # @api private
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#15
    def call(inflect); end

    private

    # @api private
    # @since 0.1.2
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#112
    def acronyms(inflect); end

    # @api private
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#87
    def irregular(inflect); end

    # @api private
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#25
    def plural(inflect); end

    # @api private
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#55
    def singular(inflect); end

    # @api private
    # @since 0.1.0
    #
    # source://dry-inflector//lib/dry/inflector/inflections/defaults.rb#105
    def uncountable(inflect); end
  end
end

# @api private
# @since 0.1.0
#
# source://dry-inflector//lib/dry/inflector.rb#317
Dry::Inflector::ORDINALIZE_TH = T.let(T.unsafe(nil), Hash)

# A set of inflection rules
#
# @api private
# @since 0.1.0
class Dry::Inflector::Rules
  # @api private
  # @return [Rules] a new instance of Rules
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/rules.rb#12
  def initialize; end

  # @api private
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/rules.rb#18
  def apply_to(word); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/rules.rb#32
  def each(&blk); end

  # @api private
  # @since 0.1.0
  #
  # source://dry-inflector//lib/dry/inflector/rules.rb#26
  def insert(index, array); end
end

# @since 0.1.0
#
# source://dry-inflector//lib/dry/inflector/version.rb#6
Dry::Inflector::VERSION = T.let(T.unsafe(nil), String)

module Dry::System
  include ::Dry::Core::Constants

  class << self
    # source://dry-system/1.0.1/lib/dry/system.rb#9
    def loader; end

    # source://dry-system/1.0.1/lib/dry/system.rb#46
    def provider_sources; end

    # source://dry-system/1.0.1/lib/dry/system.rb#33
    def register_provider_source(name, group:, source: T.unsafe(nil), &block); end

    # source://dry-system/1.0.1/lib/dry/system.rb#26
    def register_provider_sources(path); end
  end
end

class Dry::System::AutoRegistrar
  # source://dry-system/1.0.1/lib/dry/system/auto_registrar.rb#18
  def initialize(container); end

  # source://dry-system/1.0.1/lib/dry/system/auto_registrar.rb#30
  def call(component_dir); end

  # source://dry-system/1.0.1/lib/dry/system/auto_registrar.rb#16
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/auto_registrar.rb#23
  def finalize!; end

  private

  # source://dry-system/1.0.1/lib/dry/system/auto_registrar.rb#40
  def register_component?(component); end
end

class Dry::System::Component
  include ::Dry::Core::Equalizer::Methods

  # source://dry-system/1.0.1/lib/dry/system/component.rb#40
  def initialize(identifier, file_path:, namespace:, **options); end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#160
  def auto_register?; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#139
  def const_path; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#29
  def file_path; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#25
  def identifier; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#155
  def inflector; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#63
  def instance(*args, **_arg1); end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#75
  def key; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#55
  def loadable?; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#150
  def loader; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#165
  def memoize?; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#33
  def namespace; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#37
  def options; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#109
  def require_path; end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#86
  def root_key; end

  private

  # source://dry-system/1.0.1/lib/dry/system/component.rb#182
  def callable_option?(value); end

  # source://dry-system/1.0.1/lib/dry/system/component.rb#171
  def path_in_namespace; end
end

# source://dry-system/1.0.1/lib/dry/system/component.rb#18
Dry::System::Component::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Dry::System::ComponentDir
  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#26
  def initialize(config:, container:); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#41
  def component_for_key(key); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#18
  def config; end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#23
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#55
  def each_component; end

  private

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#134
  def build_component(identifier, namespace, file_path); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#100
  def component_for_path(path, namespace); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#149
  def component_options; end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#65
  def each_file; end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#77
  def files(namespace); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#115
  def find_component_file(identifier, namespace); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#92
  def full_path; end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#158
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/component_dir.rb#166
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

class Dry::System::ComponentDirAlreadyAddedError < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#14
  def initialize(dir); end
end

class Dry::System::ComponentDirNotFoundError < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#23
  def initialize(dir); end
end

class Dry::System::ComponentNotLoadableError < ::NameError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#98
  def initialize(component, error, corrections: T.unsafe(nil)); end
end

module Dry::System::Config; end

class Dry::System::Config::ComponentDir
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-configurable/1.0.1/lib/dry/configurable/instance_methods.rb#14
  def initialize(*_arg0, **_arg1); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dir.rb#208
  def auto_register?; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dir.rb#198
  def path; end

  private

  # source://dry-system/1.0.1/lib/dry/system/config/component_dir.rb#214
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dir.rb#222
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

class Dry::System::Config::ComponentDirs
  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#106
  def initialize; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#125
  def [](path); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#164
  def add(path_or_dir); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#101
  def defaults; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#185
  def delete(path); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#125
  def dir(path); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#224
  def each(&block); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#203
  def length; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#194
  def paths; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#203
  def size; end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#213
  def to_a; end

  protected

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#241
  def dirs; end

  private

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#267
  def apply_defaults_to_dir(dir); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#112
  def initialize_copy(source); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#275
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#252
  def path_and_dir(path_or_dir); end

  # source://dry-system/1.0.1/lib/dry/system/config/component_dirs.rb#283
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

class Dry::System::Config::Namespace
  include ::Dry::Core::Equalizer::Methods

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#55
  def initialize(path:, key:, const:); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#37
  def const; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#34
  def key; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#31
  def path; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#69
  def path?; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#64
  def root?; end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#46
    def default_root; end
  end
end

# source://dry-system/1.0.1/lib/dry/system/config/namespace.rb#26
Dry::System::Config::Namespace::ROOT_PATH = T.let(T.unsafe(nil), T.untyped)

class Dry::System::Config::Namespaces
  include ::Dry::Core::Equalizer::Methods

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#20
  def initialize; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#36
  def [](path); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#99
  def add(path, key: T.unsafe(nil), const: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#112
  def add_root(key: T.unsafe(nil), const: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#125
  def delete(path); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#136
  def delete_root; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#190
  def each(&block); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#165
  def empty?; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#155
  def length; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#36
  def namespace(path); end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#17
  def namespaces; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#146
  def paths; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#47
  def root; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#155
  def size; end

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#178
  def to_a; end

  private

  # source://dry-system/1.0.1/lib/dry/system/config/namespaces.rb#25
  def initialize_copy(source); end
end

class Dry::System::Container
  extend ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods
  extend ::Dry::System::Plugins

  class << self
    # source://dry-configurable/1.0.1/lib/dry/configurable/methods.rb#22
    def _configurable_finalize!(freeze_values: T.unsafe(nil)); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#409
    def add_to_load_path!(*dirs); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#582
    def after(event, &block); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#532
    def auto_registrar; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#560
    def before(event, &block); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#522
    def component_dirs; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#106
    def configure(finalize_config: T.unsafe(nil), &block); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#126
    def configured!(finalize_config: T.unsafe(nil)); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#143
    def configured?; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#317
    def finalize!(freeze: T.unsafe(nil), &block); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#284
    def finalized?; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#588
    def hooks; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#178
    def import(from:, as:, keys: T.unsafe(nil)); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#542
    def importer; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#593
    def inherited(klass); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#447
    def injector(**options); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#512
    def key?(key); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#417
    def load_registrations!(name); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#537
    def manifest_registrar; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#367
    def prepare(name); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#527
    def providers; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#273
    def register_provider(*_arg0, **_arg1, &_arg2); end

    # source://dry-core/1.0.0/lib/dry/core/container/mixin.rb#181
    def registered?(key); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#463
    def require_from_root(*paths); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#490
    def resolve(key); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#485
    def root; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#388
    def shutdown!; end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#349
    def start(name); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#382
    def stop(name); end

    protected

    # source://dry-system/1.0.1/lib/dry/system/container.rb#608
    def load_component(key); end

    private

    # source://dry-system/1.0.1/lib/dry/system/container.rb#651
    def find_component(key); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#643
    def load_imported_component(identifier, namespace:); end

    # source://dry-system/1.0.1/lib/dry/system/container.rb#637
    def load_local_component(component); end
  end
end

class Dry::System::ContainerAlreadyFinalizedError < ::StandardError; end

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::IDENTITY = T.let(T.unsafe(nil), Proc)

class Dry::System::Identifier
  include ::Dry::Core::Equalizer::Methods

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#22
  def initialize(key); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#82
  def end_with?(trailing_segments); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#103
  def include?(segments); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#19
  def key; end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#124
  def key_with_separator(separator); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#149
  def namespaced(from:, to:); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#42
  def root_key; end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#61
  def start_with?(leading_segments); end

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#19
  def to_s; end

  private

  # source://dry-system/1.0.1/lib/dry/system/identifier.rb#171
  def segments; end
end

class Dry::System::Importer
  # source://dry-system/1.0.1/lib/dry/system/importer.rb#32
  def initialize(container); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#47
  def [](name); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#27
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#58
  def finalize!; end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#64
  def import(namespace, keys: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#52
  def key?(name); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#52
  def namespace?(name); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#38
  def register(namespace:, container:, keys: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#29
  def registry; end

  private

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#107
  def build_merge_container(other, keys); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#89
  def import_all(other, namespace); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#85
  def import_keys(other, namespace, keys); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#79
  def keys_to_import(keys, item); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#101
  def merge(container, other, namespace:); end
end

class Dry::System::Importer::Item
  # source://dry-system/1.0.1/lib/dry/system/importer.rb#20
  def initialize(namespace:, container:, import_keys:); end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#18
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#18
  def import_keys; end

  # source://dry-system/1.0.1/lib/dry/system/importer.rb#18
  def namespace; end
end

class Dry::System::IndirectComponent
  include ::Dry::Core::Equalizer::Methods

  # source://dry-system/1.0.1/lib/dry/system/indirect_component.rb#24
  def initialize(identifier); end

  # source://dry-system/1.0.1/lib/dry/system/indirect_component.rb#21
  def identifier; end

  # source://dry-system/1.0.1/lib/dry/system/indirect_component.rb#47
  def key; end

  # source://dry-system/1.0.1/lib/dry/system/indirect_component.rb#36
  def loadable?; end

  # source://dry-system/1.0.1/lib/dry/system/indirect_component.rb#58
  def root_key; end
end

# source://dry-system/1.0.1/lib/dry/system/constants.rb#10
Dry::System::KEY_SEPARATOR = T.let(T.unsafe(nil), String)

class Dry::System::Loader
  class << self
    # source://dry-system/1.0.1/lib/dry/system/loader.rb#46
    def call(component, *args, **_arg2); end

    # source://dry-system/1.0.1/lib/dry/system/loader.rb#64
    def constant(component); end

    # source://dry-system/1.0.1/lib/dry/system/loader.rb#32
    def require!(component); end

    private

    # source://dry-system/1.0.1/lib/dry/system/loader.rb#79
    def singleton?(constant); end
  end
end

class Dry::System::Loader::Autoloading < ::Dry::System::Loader
  class << self
    # source://dry-system/1.0.1/lib/dry/system/loader/autoloading.rb#16
    def require!(component); end
  end
end

class Dry::System::MagicCommentsParser
  class << self
    # source://dry-system/1.0.1/lib/dry/system/magic_comments_parser.rb#14
    def call(file_name); end

    # source://dry-system/1.0.1/lib/dry/system/magic_comments_parser.rb#26
    def coerce(value); end
  end
end

# source://dry-system/1.0.1/lib/dry/system/magic_comments_parser.rb#9
Dry::System::MagicCommentsParser::COERCIONS = T.let(T.unsafe(nil), Hash)

# source://dry-system/1.0.1/lib/dry/system/magic_comments_parser.rb#7
Dry::System::MagicCommentsParser::COMMENT_RE = T.let(T.unsafe(nil), Regexp)

# source://dry-system/1.0.1/lib/dry/system/magic_comments_parser.rb#6
Dry::System::MagicCommentsParser::VALID_LINE_RE = T.let(T.unsafe(nil), Regexp)

class Dry::System::ManifestRegistrar
  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#22
  def initialize(container); end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#35
  def call(component); end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#19
  def config; end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#16
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#40
  def file_exists?(component); end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#28
  def finalize!; end

  private

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#47
  def registrations_dir; end

  # source://dry-system/1.0.1/lib/dry/system/manifest_registrar.rb#52
  def root; end
end

class Dry::System::NamespaceAlreadyAddedError < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#33
  def initialize(path); end
end

# source://dry-system/1.0.1/lib/dry/system/constants.rb#9
Dry::System::PATH_SEPARATOR = T.let(T.unsafe(nil), String)

class Dry::System::PluginDependencyMissing < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#87
  def initialize(plugin, message, gem = T.unsafe(nil)); end
end

class Dry::System::PluginNotFoundError < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#77
  def initialize(plugin_name); end
end

module Dry::System::Plugins
  # source://dry-system/1.0.1/lib/dry/system/plugins.rb#57
  def enabled_plugins; end

  # source://dry-system/1.0.1/lib/dry/system/plugins.rb#51
  def inherited(klass); end

  # source://dry-system/1.0.1/lib/dry/system/plugins.rb#37
  def use(name, **options); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins.rb#24
    def loaded_dependencies; end

    # source://dry-system/1.0.1/lib/dry/system/plugins.rb#14
    def register(name, plugin, &block); end

    # source://dry-system/1.0.1/lib/dry/system/plugins.rb#19
    def registry; end
  end
end

module Dry::System::Plugins::Bootsnap
  # source://dry-system/1.0.1/lib/dry/system/plugins/bootsnap.rb#39
  def bootsnap_available?; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/bootsnap.rb#32
  def setup_bootsnap; end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/bootsnap.rb#25
    def dependencies; end

    # source://dry-system/1.0.1/lib/dry/system/plugins/bootsnap.rb#16
    def extended(system); end
  end
end

# source://dry-system/1.0.1/lib/dry/system/plugins/bootsnap.rb#7
Dry::System::Plugins::Bootsnap::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module Dry::System::Plugins::DependencyGraph
  # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph.rb#32
  def injector(**options); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph.rb#37
  def register(key, contents = T.unsafe(nil), options = T.unsafe(nil), &block); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph.rb#27
    def dependencies; end

    # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph.rb#9
    def extended(system); end
  end
end

class Dry::System::Plugins::DependencyGraph::Strategies
  extend ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods
end

class Dry::System::Plugins::DependencyGraph::Strategies::Args < ::Dry::AutoInject::Strategies::Args
  private

  # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph/strategies.rb#32
  def define_initialize(klass); end
end

class Dry::System::Plugins::DependencyGraph::Strategies::Hash < ::Dry::AutoInject::Strategies::Hash
  private

  # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph/strategies.rb#47
  def define_initialize(klass); end
end

class Dry::System::Plugins::DependencyGraph::Strategies::Kwargs < ::Dry::AutoInject::Strategies::Kwargs
  private

  # source://dry-system/1.0.1/lib/dry/system/plugins/dependency_graph/strategies.rb#16
  def define_initialize(klass); end
end

class Dry::System::Plugins::Env < ::Module
  # source://dry-system/1.0.1/lib/dry/system/plugins/env.rb#13
  def initialize(**options); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/env.rb#23
  def extended(system); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/env.rb#18
  def inferrer; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/env.rb#10
  def options; end
end

# source://dry-system/1.0.1/lib/dry/system/plugins/env.rb#8
Dry::System::Plugins::Env::DEFAULT_INFERRER = T.let(T.unsafe(nil), Proc)

module Dry::System::Plugins::Logging
  # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#57
  def log_dir_path; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#67
  def log_file_name; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#62
  def log_file_path; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#52
  def log_level; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#37
  def register_logger; end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/logging.rb#10
    def extended(system); end
  end
end

module Dry::System::Plugins::Monitoring
  # source://dry-system/1.0.1/lib/dry/system/plugins/monitoring.rb#27
  def monitor(key, **options, &block); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/monitoring.rb#22
    def dependencies; end

    # source://dry-system/1.0.1/lib/dry/system/plugins/monitoring.rb#11
    def extended(system); end
  end
end

class Dry::System::Plugins::Monitoring::Proxy < ::SimpleDelegator
  # source://dry-system/1.0.1/lib/dry/system/plugins/monitoring/proxy.rb#43
  def initialize(target, notifications); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/monitoring/proxy.rb#12
    def for(target, key:, methods: T.unsafe(nil)); end
  end
end

module Dry::System::Plugins::Notifications
  # source://dry-system/1.0.1/lib/dry/system/plugins/notifications.rb#19
  def register_notifications; end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/notifications.rb#14
    def dependencies; end

    # source://dry-system/1.0.1/lib/dry/system/plugins/notifications.rb#9
    def extended(system); end
  end
end

class Dry::System::Plugins::Plugin
  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#15
  def initialize(name, mod, &block); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#22
  def apply_to(system, **options); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#12
  def block; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#29
  def load_dependencies(dependencies = T.unsafe(nil), gem = T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#40
  def load_dependency(dependency, gem); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#10
  def mod; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#53
  def mod_dependencies; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#8
  def name; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/plugin.rb#48
  def stateful?; end
end

class Dry::System::Plugins::Zeitwerk < ::Module
  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#23
  def initialize(loader: T.unsafe(nil), run_setup: T.unsafe(nil), eager_load: T.unsafe(nil), debug: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#20
  def debug; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#20
  def eager_load; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#32
  def extended(system); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#20
  def loader; end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#20
  def run_setup; end

  private

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#61
  def configure_loader(loader, system); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#101
  def eager_load?(system); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#95
  def get_or_define_module(parent_mod, name); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#83
  def module_for_namespace(namespace, inflector); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#70
  def push_component_dirs_to_loader(system, loader); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#46
  def setup_autoloader(system); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk.rb#11
    def dependencies; end
  end
end

class Dry::System::Plugins::Zeitwerk::CompatInflector
  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk/compat_inflector.rb#11
  def initialize(config); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk/compat_inflector.rb#15
  def camelize(string, _); end

  # source://dry-system/1.0.1/lib/dry/system/plugins/zeitwerk/compat_inflector.rb#9
  def config; end
end

class Dry::System::Provider
  # source://dry-system/1.0.1/lib/dry/system/provider.rb#130
  def initialize(name:, target_container:, source_class:, namespace: T.unsafe(nil), &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#96
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#60
  def name; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#67
  def namespace; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#154
  def prepare; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#187
  def prepared?; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#96
  def provider_container; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#127
  def source; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#166
  def start; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#194
  def started?; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#77
  def statuses; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#178
  def stop; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#201
  def stopped?; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#110
  def target; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#110
  def target_container; end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#266
  def apply; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#208
  def build_provider_container; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#225
  def run_step(step_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#84
  def step_running; end

  # source://dry-system/1.0.1/lib/dry/system/provider.rb#255
  def step_running?; end
end

class Dry::System::Provider::Source
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#123
  def initialize(provider_container:, target_container:, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#217
  def after(step_name, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#199
  def before(step_name, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#87
  def callbacks; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#102
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#136
  def inspect; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#154
  def prepare; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#102
  def provider_container; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#223
  def run_callback(hook, step); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#169
  def start; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#184
  def stop; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#119
  def target; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#119
  def target_container; end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#261
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#239
  def register(*_arg0, **_arg1, &_arg2); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#250
  def resolve(key); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#270
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#255
  def run_step_block(step_name); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#40
    def for(name:, group: T.unsafe(nil), &block); end

    # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#48
    def inherited(subclass); end

    # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#75
    def inspect; end

    # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#62
    def name; end

    # source://dry-system/1.0.1/lib/dry/system/provider/source.rb#70
    def to_s; end
  end
end

# source://dry-system/1.0.1/lib/dry/system/provider/source.rb#80
Dry::System::Provider::Source::CALLBACK_MAP = T.let(T.unsafe(nil), Hash)

class Dry::System::Provider::SourceDSL
  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#19
  def initialize(source_class); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#27
  def prepare(&block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#23
  def setting(*_arg0, **_arg1, &_arg2); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#17
  def source_class; end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#31
  def start(&block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#35
  def stop(&block); end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#41
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#49
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/provider/source_dsl.rb#13
    def evaluate(source_class, &block); end
  end
end

class Dry::System::ProviderAlreadyRegisteredError < ::ArgumentError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#45
  def initialize(provider_name); end
end

class Dry::System::ProviderNotFoundError < ::ArgumentError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#54
  def initialize(name); end
end

class Dry::System::ProviderRegistrar
  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#25
  def initialize(container); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#76
  def [](provider_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#22
  def container; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#141
  def finalize!; end

  def finalized?; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#91
  def find_and_load_provider(name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#31
  def freeze; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#82
  def key?(provider_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#165
  def prepare(provider_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#76
  def provider(provider_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#125
  def provider_files; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#19
  def providers; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#40
  def register_provider(name, namespace: T.unsafe(nil), from: T.unsafe(nil), source: T.unsafe(nil), if: T.unsafe(nil), &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#159
  def shutdown; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#171
  def start(provider_name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#106
  def start_provider_dependency(component); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#177
  def stop(provider_name); end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#199
  def build_provider(name, namespace:, source: T.unsafe(nil), &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#210
  def build_provider_from_source(name, source:, group:, namespace:, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#246
  def find_provider_file(name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#232
  def load_provider(path); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#185
  def provider_paths; end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#240
  def require_provider_file(name); end

  # source://dry-system/1.0.1/lib/dry/system/provider_registrar.rb#222
  def with_provider(provider_name); end
end

class Dry::System::ProviderSourceNotFoundError < ::StandardError
  # source://dry-system/1.0.1/lib/dry/system/errors.rb#63
  def initialize(name:, group:, keys:); end
end

class Dry::System::ProviderSourceRegistry
  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#11
  def initialize; end

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#15
  def load_sources(path); end

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#21
  def register(name:, group:, source:); end

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#25
  def register_from_block(name:, group:, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#37
  def resolve(name:, group:); end

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#9
  def sources; end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider_source_registry.rb#51
  def key(name, group); end
end

module Dry::System::ProviderSources; end
module Dry::System::ProviderSources::Settings; end

class Dry::System::ProviderSources::Settings::Config
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  private

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/config.rb#58
  def method_missing(name, *args, &block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/config.rb#66
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/config.rb#30
    def load(root:, env:, loader: T.unsafe(nil)); end
  end
end

class Dry::System::ProviderSources::Settings::InvalidSettingsError < ::ArgumentError
  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/config.rb#10
  def initialize(errors); end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/config.rb#22
  def setting_errors(errors); end
end

class Dry::System::ProviderSources::Settings::Loader
  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/loader.rb#13
  def initialize(root:, env:, store: T.unsafe(nil)); end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/loader.rb#19
  def [](key); end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/loader.rb#10
  def store; end

  private

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/loader.rb#32
  def dotenv_files(root, env); end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings/loader.rb#25
  def load_dotenv(root, env); end
end

class Dry::System::ProviderSources::Settings::Source < ::Dry::System::Provider::Source
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings.rb#10
  def prepare; end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings.rb#18
  def settings(&block); end

  # source://dry-system/1.0.1/lib/dry/system/provider_sources/settings.rb#14
  def start; end
end

# source://dry-system/1.0.1/lib/dry/system/constants.rb#7
Dry::System::RB_EXT = T.let(T.unsafe(nil), String)

# source://dry-system/1.0.1/lib/dry/system/constants.rb#8
Dry::System::RB_GLOB = T.let(T.unsafe(nil), String)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/1.0.0/lib/dry/core/constants.rb#112
Dry::System::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-system/1.0.1/lib/dry/system/constants.rb#11
Dry::System::WORD_REGEX = T.let(T.unsafe(nil), Regexp)
